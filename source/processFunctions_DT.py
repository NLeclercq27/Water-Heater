import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from scipy.interpolate import make_interp_spline
from scipy.stats import norm
import math
import random
# include the main library path (the parent folder) in the path environment variable
import os,sys
root_folder = os.path.dirname(os.path.dirname(os.path.realpath(__file__)))
sys.path.append(root_folder)
# import the library as a package (defined in __init__.py) => function calls are done through the lpackage (eg om.solve_model)
import source as procF


class WaterHeaterPool():
    
    """
    Class to create a pool of water heater and simulate its electricity 
    consumption under diverse water consumption profiles generated by a function of the class
    """
    def __init__(self, N_random_HP = 10, N_random_E = 10, N_VELIS = 0, N_NUOS = 0, nx = 40,
                 control_strategy = 'tracking_SP', T_w_supply = 14 + 273.15, T_amb = 19 + 273.15):
        """

        Parameters
        ----------
        N_random_HP : int, optional
            Number of Heat Pumps generated with random dimensions. The default is 10.
        N_random_E : int, optional
            Number of electrical water heater generated with random dimensions. The default is 10.
        N_VELIS : int, optional
            Number of Velis Electrical water heater generated. The default is 0.
        N_NUOS : int, optional
            Number of Nuos Electrical water heater generated. The default is 0.
        nx : int, optional
            Number of cell in each water heatere of the pool. The default is 40.
        control_strategy : string, optional
            Strategy chosen to operate the pool. See control_functions for more info. The default is 'tracking_SP'.
        T_w_supply : float, optional
            Temeprtature of the cold water entering the water heaters (in K). The default is 14 + 273.15.
        T_amb : float, optional
            Ambient temperature in K. The default is 19 + 273.15.

        Returns
        -------
        None.
        """
        
        # Number of water heaters by kinds         
        self.N_random_HP = N_random_HP
        self.N_random_E = N_random_E
        self.N_VELIS = N_VELIS
        self.N_NUOS = N_NUOS
        
        # Discretization of the pool
        self.nx = nx # 40 usually
        
        # Other parameters
        self.T_SP_normal = 55 + 273.15 
        self.T_SP_velis = 70 + 273.15   # Different setpoint for the Velis to respect the water temperature constraint
        self.T_init = self.T_SP_normal # Initalize teh temperature with the setpoint to avoid heating from the start
        self.T_init_Velis = self.T_SP_velis # Different initial temperature for the Velis
        self.tau_charge = 60 # seconds - time step for a charge -- 60 seconds is recommended 
        self.tau_discharge = 2 # seconds - time step for a discharge (must be a divider of 60 and maximum 60 !!)
        self.T_constraint = 38 + 273.15 # K Minimum outlet water temperature for the constraint
        self.T_max = 90 + 273.15 # K Maximum temperature of the water inside the pool
        self.T_max_HP = 55 + 273.15 # Maximum temperature until which the heat pump is working
        
        # Control strategy 
        # 'mid_day_night' - 'tracking_SP' - 'full_load' --> input of the init function
        self.pool_control_strategy = control_strategy
        
        # Ground water temperature at 14°C (avg in BE) --> can be modified to vary over the course of the year
        self.T_w_supply = T_w_supply
        
        # Ambient temperature assumed as being 19°C --> can be modified to vary over the course of the year
        self.T_amb = T_amb
        self.T_ext = T_amb # for the heat pump 
        
        self.pool_WH = []
        
        # Pre-defined Water heater parameters
        self.VELIS_params = {
        'model': 'VELIS',
        'double': True,
        'diameter': 0.21,  # m
        'height': 0.93,    # m
        'volume' : None,
        'HPWH' : False,
        'EWH' : True,
        'z_control' : 0.3,
        'z_init_E' : 0.0,
        'z_init_HP' : 0.0,
        'height_HP' : 0.0,
        'height_E' : 0.3,
        'Q_dot_peak_E' : 1250,
        'h_amb' : 0.84,
        'H_mix' : 0.15,
        'V_s' : 0,
        'W_dot_el_basis' : 0
        }
        
        self.NUOS_params = {
        'model': 'NUOS',
        'double': False,
        'diameter': 0.419,  # m
        'height': 1.09,    # m
        'volume' : None,
        'HPWH' : True,
        'EWH' : True,
        'z_control' : 0.29,
        'z_init_E' : 0.0,
        'z_init_HP' : 0.05,
        'height_HP' : 0.25,
        'height_E' : 0.16,
        'Q_dot_peak_E' : 1200,
        'h_amb' : 0.7,
        'H_mix' : 0.2,
        'V_s' : 5/1e6,
        'W_dot_el_basis' : 100
        }   
        
        self.Random_HP_params = {
        'model' : 'random_HP',
        'diameter': None,  
        'double': False,
        'HPWH' : True,
        'EWH' : True,
        'z_control' : 0.3,
        'z_init_E' : 0.0,
        'z_init_HP' : 0.05,
        'height_HP' : 0.3,
        'height_E' : 0.2,
        'h_amb' : 0.75,
        'H_mix' : 0.15,
        'W_dot_el_basis' : 100
        }
        
        self.Random_E_params = {
        'model' : 'random_E',
        'diameter': None,  
        'double': False,
        'EWH' : True,  
        'HPWH' : False,
        'z_control' : 0.3,
        'z_init_E' : 0.0,
        'z_init_HP' : 0.0,
        'height_HP' : 0.0,
        'height_E' : 0.3,
        'h_amb' : 0.75,
        'H_mix' : 0.15,
        'V_s' : 0,
        'W_dot_el_basis' : 0
        }
           
        
        
    def DHW_load_gen(self, nday, day_init = 0, bool_plot = False):
        """
        Create a water consumption profile starting at day day_init and stopping after nday.
        Return the water mass flow for 1 person
        
        References
        
        [1] Hendron, R., Burch, J., Barker, G. 2010. Tool for generating realistic
        residential hot water event schedules. Proceedings of the Fourth National Conference of
        IBPSA-USA, Simbuild 2010, New York City, USA.
        
        [2] Hendron, R., Engebrecht, C. 2010. Building America Research Benchmark
        Definition: Updated December 2009. NREL Report No TP-550-47246. Golden,
        CO:NREL
        
        [3] Spur, R., Fiala, D., Nevrala, D., Probert, D. 2006. Influence of the
        domestic hot-water daily draw-off profile on the performance of a
        hot-water store. Applied Energy, 83 pp.749-773.
        
        [4] Jordan, U., Vajen, K. 2001. Realistic Domestic Hot-Water Profiles in
        Different Time Scales. IEA-SHC Task 26 report, May 2001.

        Parameters
        ----------
        nday : int
            Number of day of the simulation.
        day_init : int, optional
            Day of the year where the simulation start. The default is 0.
        bool_plot : bool, optional
            Bool variable to plot the consumption profile generated. The default is False.

        Returns
        -------
        V_tot_litsecond : numpy array
            Array of the water consumption profile in liters per second.

        """
        
        # Fraction of Daily Usage [2]
        # Adjustment of the chance factors to get 50L/day/pers at 50 °C + (2x more sink A than sinkB, 8 times more shower than bath + 80/20% bathroom/kitchen load)
        f_daily_sinkA = 1.6*1/3.5*1/6
        f_daily_sinkB = 1.6*f_daily_sinkA*1/6
        f_daily_shwr = 0.85*1/2*1/30
        f_daily_bath = 0.85*1/4*1/400

        probday_shwr = [0.011, 0.005, 0.003, 0.005, 0.014, 0.052, 0.118, 0.117, 0.095, 0.074, 0.060, 0.047, 0.034, 0.029, 0.025, 0.026, 0.030, 0.039, 0.042, 0.042, 0.042, 0.041, 0.029, 0.021]
        probday_bath = [0.008, 0.004, 0.004, 0.004, 0.008, 0.019, 0.046, 0.058, 0.066, 0.058, 0.046, 0.035, 0.031, 0.023, 0.023, 0.023, 0.039, 0.046, 0.077, 0.100, 0.100, 0.077, 0.066, 0.039]
        probday_sink = [0.014, 0.007, 0.005, 0.005, 0.007, 0.018, 0.042, 0.062, 0.066, 0.062, 0.054, 0.050, 0.049, 0.045, 0.041, 0.043, 0.048, 0.065, 0.075, 0.069, 0.057, 0.048, 0.040, 0.027]
        
        if bool_plot == True:
            # Plot the distribution
            time_vect = np.arange(0,24,1)
    
            # Creating a smoother curve using spline interpolation
            time_new = np.linspace(time_vect.min(), time_vect.max(), 300)  # 300 points for smooth curve
            spl_shwr = make_interp_spline(time_vect, probday_shwr, k=2)
            probday_shwr_smooth = spl_shwr(time_new)
            spl_bath = make_interp_spline(time_vect, probday_bath, k=2)
            probday_bath_smooth = spl_bath(time_new)
            spl_sink = make_interp_spline(time_vect, probday_sink, k=2)
            probday_sink_smooth = spl_sink(time_new)
            
            
            plt.figure(figsize=(4,3),constrained_layout=True)
            plt.rcParams.update({'font.size':16})
            params = {
                       "text.usetex" : True,
                       "font.family" : "cm"}
            plt.rcParams.update(params)
            plt.grid()
            plt.plot(time_new, probday_shwr_smooth , 'b', linewidth = 2, label = 'Shower')
            plt.plot(time_new, probday_bath_smooth , 'r', linewidth = 2, label = 'Bath')
            plt.plot(time_new, probday_sink_smooth , 'g',  linewidth = 2 , label = 'Sink')
            plt.xlabel('Time [hour]', fontsize=16,  fontname="Times New Roman")
            plt.ylabel('Probability [-]', fontsize=16, fontname="Times New Roman")       
            plt.legend(fontsize=12, loc='best')  
        
        
        # Characteristics [3] & [4]
        # A: short draw-off; B:medium draw-off; C:shower; D:bath
        V_dot_A_m = 1/60/1000 #m^3/s
        V_dot_B_m = 2/60/1000 #m^3/s
        V_dot_C_m = 8/60/1000 #m^3/s
        V_dot_D_m = 14/60/1000 #m^3/s
        
        V_dot_A_std = 1/60/1000 #m^3/s
        V_dot_B_std = 1/60/1000 #m^3/s
        V_dot_C_std = 2/60/1000 #m^3/s
        V_dot_D_std = 2/60/1000 #m^3/s
        
        DELTAt_A_m = 1*60 #sec
        DELTAt_B_m = 1*60 #sec
        DELTAt_C_m = 5*60 #sec
        DELTAt_D_m = 10*60 #sec
        
        DELTAt_A_std = 0.5*60 #sec
        DELTAt_B_std = 0.5*60 #sec
        DELTAt_C_std = 2.5*60 #sec
        DELTAt_D_std = 5*60 #sec


        #Time
        ti = day_init*24*60
        DELTAtmin = 1
        tf = ti + nday*24*60/DELTAtmin
        nstep = int(nday*24*60/DELTAtmin)

        # Variables
        minweek = np.zeros(nstep, dtype = int) # minutes of the week (reset after 10080)
        fsinkA = np.zeros(nstep) #boolean to check activation of event sinkA
        fsinkB = np.zeros(nstep) #boolean to check activation of event sinkB
        fshwr = np.zeros(nstep) #boolean to check activation of event fshwr
        fbath = np.zeros(nstep) #boolean to check activation of event fbath
        V_dot_sinkA = np.zeros(nstep) # volume flow rate of type sinkA for the whole period
        V_dot_sinkB = np.zeros(nstep) # volume flow rate of type sinkB for the whole period
        V_dot_shwr = np.zeros(nstep) # volume flow rate of type shower for the whole period
        V_dot_bath = np.zeros(nstep) # volume flow rate of type bath for the whole period
        V_dot_tot = np.zeros(nstep)  #  total volume flow rate of type sinkA for the whole period
        V_dot_tot_lmin = np.zeros(nstep) #  total volume flow rate of type sinkA for the whole period in l/min
        n_sinkA = np.zeros(nday) #  number of type sinkA occurence per day
        n_sinkB = np.zeros(nday) #  number of type sinkB occurence per day
        n_shwr = np.zeros(nday) #  number of type shower occurence per day
        n_bath = np.zeros(nday) #  number of type bath occurence per day
        t_sinkA = np.zeros(nday) # total time of type sinkA per day 
        t_sinkB = np.zeros(nday) # total time of type sinkb per day 
        t_shwr = np.zeros(nday) # total time of type shower per day 
        t_bath = np.zeros(nday) # total time of type bath per day 
        V_sinkA_lit = np.zeros(nday) # total volume of type sinkA in liters per day 
        V_sinkB_lit = np.zeros(nday) # total volume of type sinkA in liters per day 
        V_shwr_lit = np.zeros(nday) # total volume of type sinkA in liters per day 
        V_bath_lit = np.zeros(nday) # total volume of type sinkA in liters per day 
        self.V_tot_lit = np.zeros(nday) # total volume in liters per day 
        V_tot_lit_yr = np.zeros(int(np.ceil(nday/365))) # total volume per year 


        flowAmat = np.zeros((int(7*24*60/DELTAtmin), int(np.ceil(nday/7))))
        flowBmat = np.zeros((int(7*24*60/DELTAtmin), int(np.ceil(nday/7))))
        flowCmat = np.zeros((int(7*24*60/DELTAtmin), int(np.ceil(nday/7))))
        flowDmat = np.zeros((int(7*24*60/DELTAtmin), int(np.ceil(nday/7))))
        
        fAmat = np.zeros((int(7*24*60/DELTAtmin), int(np.ceil(nday/7))))
        fBmat = np.zeros((int(7*24*60/DELTAtmin), int(np.ceil(nday/7))))
        fCmat = np.zeros((int(7*24*60/DELTAtmin), int(np.ceil(nday/7))))
        fDmat = np.zeros((int(7*24*60/DELTAtmin), int(np.ceil(nday/7))))


        # Initialize indexes
        fA = 0 
        fAprev = 0
        iA = -1
        jA = -1
        flowA = 0
        fB = 0 
        fBprev = 0
        iB = -1
        jB = -1
        flowB = 0
        fC = 0 
        fCprev = 0
        iC = -1
        jC = -1
        flowC = 0
        fD = 0 
        fDprev = 0
        iD = -1
        jD = -1
        flowD = 0
        
        # Initialize random variable lists + starting time vector
        bA = []
        bB = []
        bC = []
        bD = []
        cA = []
        cB = []
        cC = []
        cD = []
        tstartA = []
        tstartB = []
        tstartC = []
        tstartD = []
        tendA = []
        tendB = []
        tendC = []
        tendD = []

        cumprobdurA = norm.cdf(np.arange(0, 2400), loc = DELTAt_A_m, scale = DELTAt_A_std) # in second 
        cumprobdurB = norm.cdf(np.arange(0, 2400), loc = DELTAt_B_m, scale = DELTAt_B_std)
        cumprobdurC = norm.cdf(np.arange(0, 2400), loc = DELTAt_C_m, scale = DELTAt_C_std)
        cumprobdurD = norm.cdf(np.arange(0, 2400), loc = DELTAt_D_m, scale = DELTAt_D_std)

        # Model [4]
            
        for t in np.arange(int(ti), int(tf)):

            hour = t/60
            # Hour of the day (1-24)
            hourday = (hour % 24)
            
            day = t / (24 * 60)
            dayi = int(np.floor(day))
            
            # Day of the week (1-7)
            dayweek = (day %  7)
            
            # day of the year (1-365)
            dayyr = day % 365

            
            # Year
            yr = t / (24 * 60 * 365)
            yri = int(np.floor(yr))
            
            # Minute of the week
            # Create a list or array to hold minweek values, assuming t is an integer
            # minweek = np.zeros(t+1)  # Pre-allocate space
            minweek[t] = t % (7 * 24 * 60)
            # Week of the year
            week = t / (24 * 60 * 7)
            weeki = int(np.floor(week))

            # probseason - Course of probabilities during the year
            P = 365*24*60
            A = 0.1
            B = - 61.75*24*60
            probseason = 1 + A*np.sin(2*np.pi*(t - B)/DELTAtmin*1/P)
            # probweek - Course of probabilities during the week (variable probability for taking a bath)
            probweekA = 1
            probweekB = 1
            probweekC = 1
            if dayweek <= 4:
                probweekD = 0.5
            elif dayweek > 4 and dayweek <= 5:
                probweekD = 0.8
            elif dayweek > 5 and dayweek <= 6:
                probweekD = 1.9
            elif dayweek > 6 and dayweek <= 7:
                probweekD = 2.3
            
            # probday - Daily distribution of probabilities
            probdayA = probday_sink[math.trunc((hourday))]
            probdayB = probday_sink[math.trunc((hourday))]
            probdayC = probday_shwr[math.trunc((hourday))]
            probdayD = probday_bath[math.trunc((hourday))]
            
            
            
            # probholiday - Holiday period
            if (dayyr >= 195 and dayyr <= 208) or (dayyr >= 220 and dayyr <= 233):
                probholiday = 0.5
            else:
                probholiday = 1
            
            # probyear - Global probability function
            probyearA = f_daily_sinkA * probseason * probweekA * probdayA * probholiday
            probyearB = f_daily_sinkB * probseason * probweekB * probdayB * probholiday
            probyearC = f_daily_shwr * probseason * probweekC * probdayC * probholiday
            probyearD = f_daily_bath * probseason * probweekD * probdayD * probholiday
            
            
            # Stochastic process
            if t < 1:
                fsinkA[t] = 0
                fsinkB[t] = 0
                fshwr[t] = 0
                fbath[t] = 0
                V_dot_sinkA[t] = 0
                V_dot_sinkB[t] = 0
                V_dot_shwr[t] = 0
                V_dot_bath[t] = 0

            else:
                aA = random.random()
                aB = random.random()
                aC = random.random()
                aD = random.random()
                # Is appliance (water use case A) already functioning ?
                if fAprev == 0: #NO
                    # Stochastic process to determine if an operation cycle (use of water from case A) is starting
                    if aA < probyearA: # process is starting 
                        iA = iA + 1
                        fA = 1
                        tstartA.append(t)
                        bA.append(random.random()) #duration probability index
                        cA.append(max(0, np.random.normal(V_dot_A_m, V_dot_A_std))) # pick-up flow
                        flowA = cA[iA]
                    else: # Nothing is starting
                        fA = 0
                        flowA = 0
                    
                    # Is appliance already functioning ?
                else: #YES
                    # What is the duration of the on-going cycle ?
                    DELTAtonA = max(0,(t-tstartA[iA]))
                    # print(bA[iA], cumprobdurA[DELTAtonA*60], tstartA[iA], t)
                    if bA[iA] < cumprobdurA[DELTAtonA*60]:
                        #Cycle stops
                        jA = jA + 1
                        tendA.append(t)
                        fA = 0
                        flowA = 0
                    else: # cycle continue 
                        fA = 1
                        flowA = cA[iA]
                    
                fAprev = fA
                # Is appliance (water use case B) already functioning ?
                if fBprev == 0: #NO
                    # Stochastic process to determine if an operation cycle (use of water from case A) is starting
                    if aB < probyearB: # process is starting 
                        iB = iB + 1
                        fB = 1
                        tstartB.append(t)
                        bB.append(random.random()) #duration probability index
                        cB.append(max(0, np.random.normal(V_dot_B_m, V_dot_B_std))) # pick-up flow
                        flowB = cB[iB]
                    else: # Nothing is starting
                        fB = 0
                        flowB = 0
                    
                    # Is appliance already functioning ?
                else: #YES
                    # What is the duration of the on-going cycle ?
                    DELTAtonB = max(0,(t-tstartB[iB]))
                    if bB[iB] < cumprobdurB[DELTAtonB*60]:
                        #Cycle stops
                        jB = jB + 1
                        tendB.append(t)
                        fB = 0
                        flowB = 0
                    else: # cycle continue 
                        fB = 1
                        flowB = cB[iB]
                    
                fBprev = fB
                # Is appliance (water use case C) already functioning ?
                if fCprev == 0: #NO
                    # Stochastic process to determine if an operation cycle (use of water from case A) is starting
                    if aC < probyearC: # process is starting 
                        iC = iC + 1
                        fC = 1
                        tstartC.append(t)
                        bC.append(random.random()) #duration probability index
                        cC.append(max(0, np.random.normal(V_dot_C_m, V_dot_C_std))) # pick-up flow
                        flowC = cC[iC]
                    else: # Nothing is starting
                        fC = 0
                        flowC = 0
                    
                    # Is appliance already functioning ?
                else: #YES
                    # What is the duration of the on-going cycle ?
                    DELTAtonC = max(0,(t-tstartC[iC]))
                    if bC[iC] < cumprobdurC[DELTAtonC*60]:
                        #Cycle stops
                        jC = jC + 1
                        tendC.append(t)
                        fC = 0
                        flowC = 0
                    else: # cycle continue 
                        fC = 1
                        flowC = cC[iC]
                    
                fCprev = fC
                # Is appliance (water use case D) already functioning ?
                if fDprev == 0: #NO
                    # Stochastic process to determine if an operation cycle (use of water from case A) is starting
                    if aD < probyearD: # process is starting 
                        iD = iD + 1
                        fD = 1
                        tstartD.append(t)
                        bD.append(random.random()) #duration probability index
                        cD.append(max(0, np.random.normal(V_dot_D_m, V_dot_D_std))) # pick-up flow
                        flowD = cD[iD]
                    else: # Nothing is starting
                        fD = 0
                        flowD = 0
                    
                    # Is appliance already functioning ?
                else: #YES
                    # What is the duration of the on-going cycle ?
                    DELTAtonD = max(0,(t-tstartD[iD]))
                    if bD[iD] < cumprobdurD[DELTAtonD*60]:
                        #Cycle stops
                        jD = jD + 1
                        tendD.append(t)
                        fD = 0
                        flowD = 0
                    else: # cycle continue 
                        fD = 1
                        flowD = cD[iD]
                    
                fDprev = fD
                
            # flow (m3/s to liters/s)
            flowA = flowA*1000
            flowB = flowB*1000
            flowC = flowC*1000
            flowD = flowD*1000
            flowtot = flowA + flowB + flowC + flowD
            
            # min*week matrix
            flowAmat[minweek[t], weeki] = flowA
            flowBmat[minweek[t], weeki] = flowB
            flowCmat[minweek[t], weeki] = flowC
            flowDmat[minweek[t], weeki] = flowD
        
            V_dot_sinkA[t] = flowA #l/s
            V_dot_sinkB[t] = flowB
            V_dot_shwr[t] = flowC
            V_dot_bath[t] = flowD
            V_dot_tot[t] = flowtot
            V_dot_tot_lmin[t] = flowtot*60
            
            #DHW use
            fsinkA[t] = fA
            fsinkB[t] = fB
            fshwr[t] = fC
            fbath[t] = fD
        
            fAmat[minweek[t], weeki] = fA
            fBmat[minweek[t], weeki] = fB
            fCmat[minweek[t], weeki] = fC
            fDmat[minweek[t], weeki] = fD
            
            #Daily data
            #Events occurence
            if dayi == 0:
                n_sinkA[dayi] = iA
                n_sinkB[dayi] = iB
                n_shwr[dayi] = iC
                n_bath[dayi] = iD
            else:
                n_sinkA[dayi] = iA - sum(n_sinkA[:dayi])
                n_sinkB[dayi] = iB - sum(n_sinkB[:dayi])
                n_shwr[dayi] = iC - sum(n_shwr[:dayi])
                n_bath[dayi] = iD - sum(n_bath[:dayi])

            
            # Events duration in minutes
            t_sinkA[dayi] = t_sinkA[dayi] + fA
            t_sinkB[dayi] = t_sinkB[dayi] + fB
            t_shwr[dayi] = t_shwr[dayi] + fC
            t_bath[dayi] = t_bath[dayi] + fD
            
            # Events volume in liters
            V_sinkA_lit[dayi] = V_sinkA_lit[dayi] + flowA*DELTAtmin*60
            V_sinkB_lit[dayi] = V_sinkB_lit[dayi] + flowB*DELTAtmin*60
            V_shwr_lit[dayi] = V_shwr_lit[dayi] + flowC*DELTAtmin*60
            V_bath_lit[dayi] = V_bath_lit[dayi] + flowD*DELTAtmin*60
            self.V_tot_lit[dayi] = V_sinkA_lit[dayi] + V_sinkB_lit[dayi] + V_shwr_lit[dayi] + V_bath_lit[dayi]
            
            # Annual volume in liters
            V_tot_lit_yr[yri] = V_tot_lit_yr[yri] + flowtot*DELTAtmin*60
            
        # Average daily usage
        
        # Total daily volume
        self.V_tot_davg_lit = np.mean(self.V_tot_lit)
        V_sinkA_davg_lit = np.mean(V_sinkA_lit)
        V_sinkB_davg_lit = np.mean(V_sinkB_lit)
        V_shwr_davg_lit = np.mean(V_shwr_lit)
        V_bath_davg_lit = np.mean(V_bath_lit)
        
        # Daily time of use (minutes)
        t_sinkA_davg = np.mean(t_sinkA)
        t_sinkB_davg = np.mean(t_sinkB)
        t_shwr_davg = np.mean(t_shwr)
        t_bath_davg = np.mean(t_bath)
        
        # Daily number of occurrences
        n_sinkA_davg = np.mean(n_sinkA)
        n_sinkB_davg = np.mean(n_sinkB)
        n_shwr_davg = np.mean(n_shwr)
        n_bath_davg = np.mean(n_bath)
        
        V_tot_litsecond = V_dot_tot
        
        
        return V_tot_litsecond
        
    def generate_pool(self):   
        """
        Generate the pool of water heater
        Able to create random electric water heaters or heat pump water heater
        Able to create a Velis Electrical Water heater or a Nuos Heat pump water 
        heater (based on validated parameters)
        
        The water heaters (class) are gathered in a list called self.pool_WH        

        Returns
        -------
        None.

        """
        
        V_range = [120/1e3, 150/1e3, 180/1e3, 210/1e3, 250/1e3, 280/1e3] # Range of volumes to be picked up from
        Power_range = [2000, 2200, 2400, 2600, 2800, 3000] # W for EWH
        Power_assist_range = [500, 750, 1000, 1250, 1500, 1750] # W to assist the heat pump
        V_s_range = [3/1e6, 5/1e6, 7/1e6, 9/1e6, 11/1e6, 13/1e6] # Volume of the HP compressors in m^3
        height_mean = 1 # m  Average height
        height_std = 0.2 # m Standard deivation of the height
        
        
        # Velis water heater
        for i in range(self.N_VELIS):
            WH = self.create_WH(self.VELIS_params)
            self.pool_WH.append(WH) 
        
        # Nuos water heater    
        for i in range(self.N_NUOS):
            WH = self.create_WH(self.NUOS_params)
            self.pool_WH.append(WH) 
        
        # Random electrical water heater
        for i in range(self.N_random_E):
            # generate random dimensions/characteristics
            volume = random.choice(V_range)
            # volume = 210/1e3
            height = np.random.normal(height_mean, height_std)
            # power = random.choice(Power_range)
            power = Power_range[np.where(np.array(V_range) == volume)[0][0]]
            
            # add the dimensions/characteristics to the parameter dictionary 
            self.Random_E_params['volume'] = volume
            self.Random_E_params['height'] = height
            self.Random_E_params['Q_dot_peak_E'] = power
            
            # Creation of the water heater and inclusion in the pool
            WH = self.create_WH(self.Random_E_params)
            self.pool_WH.append(WH) 
         
        # Random heat pump water heater   
        for i in range(self.N_random_HP):
            # generate random dimensions/characteristics
            volume = random.choice(V_range)
            height = np.random.normal(height_mean, height_std)
            power_el_assist = random.choice(Power_assist_range)
            # V_s = random.choice(V_s_range)
            V_s = V_s_range[np.where(np.array(V_range) == volume)[0][0]]
            
            # add the dimensions/characteristics to the parameter dictionary 
            self.Random_HP_params['volume'] = volume
            self.Random_HP_params['height'] = height
            self.Random_HP_params['Q_dot_peak_E'] = power_el_assist
            self.Random_HP_params['V_s'] = V_s
            
            # Creation of the water heater and inclusion in the pool
            WH = self.create_WH(self.Random_HP_params)
            self.pool_WH.append(WH) 
            


    def create_WH(self, params): 
        """
        Create a water heater (class) using the set of given parameters 
        Initiate the class using wh.procF.WaterHeater
        Create the heating system based on the parameters provided in the input params (given in the generate_WH function)
        Add the model parameters also based on the input params 

        Parameters
        ----------
        params : dict
            Dictionnary gathering the water heater parameters.

        Returns
        -------
        WH : class
            Water heater class created.
        """
        # Model creation
        WH = procF.wh.WaterHeater(Model = params['model'], Volume = params['volume'], Height = params['height'], Diameter = params['diameter'], EWH = params['EWH'], HPWH = params['HPWH'], double = params['double'])    
        # Definition of the heating system geometry
        WH.Heating_system(z_control = params['z_control'], z_init_E = params['z_init_E'], z_init_HP = params['z_init_HP'], height_E = params['height_E'], height_HP = params['height_HP'], Q_dot_peak_E = params['Q_dot_peak_E'])
        # Tank model empirical parameters 
        WH.Model_parameters(h_amb = params['h_amb'], H_mix = params['H_mix'], V_s = params['V_s'], W_dot_el_basis = params['W_dot_el_basis'])
        #MN model initialization
        nx = self.nx
        # The first temperature initialization vector is used for the first tank 
        if WH.Model =='VELIS':
            T_init = self.T_init_Velis  # Initial temperature distribution 
            T_vect_init = np.full(nx, T_init)
            WH.MN_model_init(nx, T_vect_init, T_vect_init)
        else: 
            T_init = self.T_init  # Initial temperature distribution  
            T_vect_init = np.full(nx, T_init)
            WH.MN_model_init(nx, T_vect_init)
        return WH 

    def attach_WaterConsumptionProfile(self, nday, day_init):
        """
        Function to attach water consumption profiles to the water heaters 

        Parameters
        ----------
        nday : int
            Number of days of the simulation.
        day_init : int
            Starting day of the year.

        Returns
        -------
        None.

        """
        
        for WH in self.pool_WH:
            V_dot_tot = 0 
            # number of people using the water heater in the house 
            WH.usage_profiles = WH.Total_volume//0.06 + 1*random.choice([0, 1]) 
            # 60 liters per person + a potential extra person
            # Loop to cumulate the water consumption profile of every people in the house
            for k in range(int(WH.usage_profiles)):
                V_dot_tot += self.DHW_load_gen(nday, day_init = day_init)
        
            WH.flow_rate_lps = V_dot_tot
        
    def simulate_pool_parallel(self,  nday, day_init = 0):
        
        """
        Simulate the pool of water heaters stating from day day_init of the year
        and finishing after nday (should be an int).
        Generate the total electrical consumption profile of the pool of water heaters
        Every water heater is simulated in parallel --> first loop on the time vector self.time_vect_com (60 seconds of time step)
        This function can be used but the control can also be done directly in the main script (digital twin) along with the initialize_sim and record_results functions

        Parameters
        ----------
        nday : int
            Number of days of the simulation.
        day_init : int
            Starting day of the year.

        Returns
        -------
        None.

        """

        self.time_vect_com = np.arange(0, nday*24*60*60, 60) # Time vector
        self.P_el_mat = np.zeros([len(self.time_vect_com),len(self.pool_WH)]) # Matrix gathering the electrical consumption
        self.T_out_mat = np.zeros([len(self.time_vect_com),len(self.pool_WH)]) # Matrix gathering the outlet T
        self.T_mean_mat = np.zeros([len(self.time_vect_com),len(self.pool_WH)]) # Matrix gathering the avg T
        self.T_probe_2Dlist = [[(0.0 , 0.0)] * len(self.time_vect_com) for _ in range(len(self.pool_WH))] # list of tuple with the probe temperature
        self.P_vect_cum = np.zeros(len(self.time_vect_com)) # Vector of the elecrical consumption of the pool
        self.V_dot_vect_cum = 0
        self.T_constraint_bool_vect = np.ones(len(self.pool_WH)) # Vector of the size of the pool checking the respect of the constraint (T_w_out > T_constraint)
        self.attach_WaterConsumptionProfile(nday, day_init) 
        self.E_sto_vect = np.zeros(len(self.time_vect_com)) # Vector of the available energy storage
        self.P_sto_vect = np.zeros(len(self.time_vect_com)) # Vector of the available power storage
        self.E_cons_tot_kwh = 0
        self.Q_amb_tot_kwh = 0
        print(f"Simulation of {self.N_VELIS} VELIS, {self.N_NUOS} NUOS, {self.N_random_E} random EWH and {self.N_random_HP} random HPWH...")       
        
        # Loop over the time
        for t in range(len(self.time_vect_com)):
            cnt = 0
            P_vect_cum = 0
            # Loop over the water heaters
            for WH in self.pool_WH:
                T_out_wh = self.T_init  # no use of water when the simulation starts
                index_pos = int(np.round(self.nx*(WH.control_ratio)))
                
                # Get the probe temperature and the average temperature + set the setpoint 
                # The Velis has two tanks so different variable sizes
                if WH.Model == 'VELIS':
                    self.T_probe_2Dlist[cnt][t] = (WH.T_record1[-1][index_pos], WH.T_record2[-1][index_pos])
                    T_SP = self.T_SP_velis
                    self.T_mean_mat[t,cnt] = np.mean([WH.T_record1[-1] , WH.T_record2[-1]])

                else: 
                    self.T_probe_2Dlist[cnt][t] = (WH.T_record1[-1][index_pos], None)
                    T_SP = self.T_SP_normal
                    self.T_mean_mat[t,cnt] = np.mean(WH.T_record1[-1])

                if WH.flow_rate_lps[t] == 0: 
                    # Period of charge/rest
                    dt = self.tau_charge# seconds                   
                    m_dot = 0

                    switch1, switch2 = self.control_functions(WH, t*60, self.T_probe_2Dlist[cnt][t], T_SP, strategy = self.pool_control_strategy)
                    time_period = 60 # seconds
                    WH.MN_model_nocontrol(dt, time_period, m_dot, self.T_w_supply, self.T_amb, switch1, switch2, self.T_ext)       
                
                else: 
                    # Period of discharge - use of water
                    
                    dt = self.tau_discharge# seconds
                    time_period = 60 # seconds
                    T_out_wh = WH.T_w_out[-1]
                    WH.flow_rate_lps[t] = self.correct_flow_rate(WH.flow_rate_lps[t], T_out_wh)
                    m_dot = WH.flow_rate_lps[t]
                    switch1, switch2 = self.control_functions(WH, t*60, self.T_probe_2Dlist[cnt][t], T_SP, strategy = self.pool_control_strategy)
                    WH.MN_model_nocontrol(dt, time_period, m_dot, self.T_w_supply, self.T_amb, switch1, switch2, self.T_ext)

                P_vect_cum += WH.W_dot_cons_tot[-1]
                self.T_out_mat[t,cnt] = WH.T_w_out[-1]
                self.P_el_mat[t,cnt] = WH.W_dot_cons_tot[-1]
                self.E_cons_tot_kwh += WH.W_dot_cons_tot[-1]/3.6/1e6*60 # kWh
                self.Q_amb_tot_kwh += -WH.Q_dot_amb[-1]/3.6/1e6*60
                if WH.T_w_out[-1] < self.T_constraint:
                    self.T_constraint_bool_vect[cnt] = 0
                if t == 0:
                    self.V_dot_vect_cum += WH.flow_rate_lps   
                cnt +=1
            self.P_vect_cum[t] = P_vect_cum
            P_sto, E_sto = self.E_storage_potential()
            self.E_sto_vect[t] = E_sto
            self.P_sto_vect[t] = P_sto
            
            # Print evolution of the simulation
            if t/60 % 4 == 0:
                print(f'{int(t/60 + 4)} hours simulated') 
        print(f'Ratio of temperature constraints ({self.T_constraint -273.15:.2f}°C) respected: {int(sum(self.T_constraint_bool_vect))}/{len(self.pool_WH)}')        
    
    def initialize_sim(self, nday, day_init = 0):
        """
        Function initializing the simulation variable in case the control of the WH is done 
        in the main script (digital twin).

        Parameters
        ----------
        nday : int
            Number of days of the simulation.
        day_init : int
            Starting day of the year. The default is 0.

        Returns
        -------
        None.

        """
        self.time_vect_com = np.arange(0, nday*24*60*60, 60) # Time vector
        self.P_el_mat = np.zeros([len(self.time_vect_com),len(self.pool_WH)]) # Matrix gathering the electrical consumption
        self.T_out_mat = np.zeros([len(self.time_vect_com),len(self.pool_WH)]) # Matrix gathering the outlet T
        self.T_mean_mat = np.zeros([len(self.time_vect_com),len(self.pool_WH)]) # Matrix gathering the avg T
        self.T_probe_2Dlist = [[(0.0 , 0.0)] * len(self.time_vect_com) for _ in range(len(self.pool_WH))] # List of tuple with the probe temperature
        self.P_vect_cum = np.zeros(len(self.time_vect_com)) # Vector of the elecrical consumption of the pool
        self.V_dot_vect_cum = 0
        self.T_constraint_bool_vect = np.ones(len(self.pool_WH)) # Vector of the size of the pool checking the respect of the constraint (T_w_out > T_constraint)
        self.attach_WaterConsumptionProfile(nday, day_init)
        self.E_sto_vect = np.zeros(len(self.time_vect_com)) # Vector of the available energy storage
        self.P_sto_vect = np.zeros(len(self.time_vect_com)) # Vector of the available power storage
        self.E_cons_tot_kwh = 0
        self.Q_amb_tot_kwh = 0
        self.P_el_vect_cum = 0
        print(f"Simulation of {self.N_VELIS} VELIS, {self.N_NUOS} NUOS, {self.N_random_E} random EWH and {self.N_random_HP} random HPWH...")       
    
    
    def WH_iteration(self, WH, t, cnt_wh, switch1, switch2): 
        """
        Function iterating on a single water heater in case the control of the WH is done 
        in the main script (digital twin).

        Parameters
        ----------
        WH : class
            Water heater class.
        t : time
            Time index.
        cnt_wh : int
            Index of the water heater.
        switch1 : bool
            Activating boolean of the heating resistor.
        switch2 : bool
            Activating boolean of the compressor (for the HP) or second tank resistor.

        Returns
        -------
        self.T_probe_2Dlist[cnt_wh][t] : Tuple
            Tuple of the probe temperature (one or two tanks).

        """
        
        T_out_wh = self.T_init  # no use of water when the simulation starts
        index_pos = int(np.round(self.nx*(WH.control_ratio)))
        time_period = 60 # time step in seconds
        if WH.Model == 'VELIS':
            self.T_probe_2Dlist[cnt_wh][t] = (WH.T_record1[-1][index_pos], WH.T_record2[-1][index_pos])
            T_SP = self.T_SP_velis
            self.T_mean_mat[t,cnt_wh] = np.mean([WH.T_record1[-1] , WH.T_record2[-1]])

        else: 
            self.T_probe_2Dlist[cnt_wh][t] = (WH.T_record1[-1][index_pos], None)
            T_SP = self.T_SP_normal
            self.T_mean_mat[t,cnt_wh] = np.mean(WH.T_record1[-1])
            
        # Check is there is a flow rate or not 
        if WH.flow_rate_lps[t] == 0: 
            # Period of charge/rest                 
            WH.MN_model_nocontrol(self.tau_charge, time_period, WH.flow_rate_lps[t], self.T_w_supply, self.T_amb, switch1, switch2, self.T_ext)
        else: 
            # Period of discharge - use of water
            T_out_wh = WH.T_w_out[-1]
            WH.flow_rate_lps[t] = self.correct_flow_rate(WH.flow_rate_lps[t], T_out_wh)
            m_dot = WH.flow_rate_lps[t]
            WH.MN_model_nocontrol(self.tau_discharge, time_period, WH.flow_rate_lps[t], self.T_w_supply, self.T_amb, switch1, switch2, self.T_ext)
        
        # Adding results to the pool
        self.P_el_vect_cum += WH.W_dot_cons_tot[-1]
        self.T_out_mat[t,cnt_wh] = WH.T_w_out[-1]
        self.P_el_mat[t,cnt_wh] = WH.W_dot_cons_tot[-1]
        self.E_cons_tot_kwh += WH.W_dot_cons_tot[-1]/3.6/1e6*60 # kWh
        self.Q_amb_tot_kwh += -WH.Q_dot_amb[-1]/3.6/1e6*60
        if WH.T_w_out[-1] < self.T_constraint:
            self.T_constraint_bool_vect[cnt_wh] = 0
        if t == 0:
            self.V_dot_vect_cum += WH.flow_rate_lps           
         
        return self.T_probe_2Dlist[cnt_wh][t] 
    
    def record_results(self,t):
        """
        When a open loop is used to simulate the water heater (in the main script), this function is 
        used to store the results in the corresponding variables.

        Parameters
        ----------
        t : int
            time loop index.
        Returns
        -------
        None.

        """
        self.P_vect_cum[t] = self.P_el_vect_cum
        P_sto, E_sto = self.E_storage_potential()
        self.E_sto_vect[t] = E_sto
        self.P_sto_vect[t] = P_sto
        # Print evolution of the simulation
        if t/60 % 4 == 0:
            print(f'{int(t/60 + 4)} hours simulated') 

    def control_functions(self, WH, time, T_probe, T_SP, strategy = 'tracking_SP') :    
        """
        

        Parameters
        ----------
        WH : class
            The water heater controlled.
        time : int
            Time of the day in second.
        T_probe : float
            Temperature measurement coming from the probe inside the tank(s).
        T_SP : float
            Temperature setpoint.
        strategy : string, optional
            Control strategy of the water heater
            Several strategy can be selected: 

            "tracking_SP": 
                - The system stops heating when the set point is exceeded by a temperature difference DT_high
                - The system starts heating when the control temperatrure is DT_low below the set point
                - switch2 always has the priority on switch 1 for the velis
                - The additional heating resistor is not used for the HPWH
            "mid_day_night": 
                - The system starts heating at midday or midnight and stops when the temperature 
                  setpoint + DThigh is reached
            "full_heat": 
                - heat the system until the maximum water temperature is reached (80°C in every water heater)
                  strategy for electricity storage (gives the maximum power and energy that can be stored over time)
                - heat the HPWH storage using the electrical resistor as well . The default is 'tracking_SP'.

        Returns
        -------
        switch1 : bool
            Activate the electrical resistor (True) or not (False).
        switch2 : bool
            Activate the compressor if a heat pump is used (True) or not (False).

        """

        DT_high = 3 # Value that can be exceeded over the setpoint
        DT_low = 3 # Value subtracted to the setpoint where the system restart heating
        hyst = DT_low + DT_high # Total hysteresis range
        T_SP = T_SP + DT_high
        if strategy == 'tracking_SP':
            if WH.Model == 'VELIS': # If the Velis is used the strategy never heats both tank at the same time              
                T_probe1 = T_probe[0]
                T_probe2 = T_probe[1]
                if T_probe1 >= T_SP: # SP + DT_high exceeded --> no heating
                    switch1 = False
                elif T_probe1 <= T_SP - hyst: # SP - DT_low passed --> restart heating
                    switch1 = True
                else: # Same state as before if no change is obesrved (heating or not)
                    switch1 = WH.switch1
                if T_probe2 >= T_SP: # Same strategy for the second tank and for the following type of water heaters
                    switch2 = False
                elif T_probe2 <= T_SP - hyst:
                    switch2 = True
                else:
                    switch2 = WH.switch2
                if switch1 == True and switch2 == True: # Gives priority to tank number 2 the heat (from which the water is taken out)
                    switch1 = False
                    
            elif WH.Model == 'random_E':   
                T_probe = T_probe[0]
                if T_probe >= T_SP:
                    switch1 = False
                elif T_probe <= T_SP - hyst:
                    switch1 = True
                else:
                    switch1 = WH.switch1
                switch2 = False
                
            else: # Heat pump case --> switch 2 for the compressor and switch 1 for the additional resistor
                T_probe = T_probe[0]
                if T_probe >= T_SP:
                    switch2 = False
                elif T_probe <= T_SP - hyst:
                    switch2 = True
                else:
                    switch2 = WH.switch2
                switch1 = False # the heating resisotr is never used in this strategy (for a heat pump)
                if T_probe > self.T_max_HP + DT_high: # The heat pump can only operate up to maximum temperature 
                    switch2 = False

        if strategy ==  'mid_day_night': # Strategy to heat only in given time ranges but similar to tracking SP 
            
            if time == 0 or time == 12*60*60 or WH.switch1 == True or WH.switch2 == True:
                if WH.Model == 'VELIS':
                    T_probe1 = T_probe[0]
                    T_probe2 = T_probe[1]
                    if T_probe1 >= T_SP:
                        switch1 = False
                    elif T_probe1 <= T_SP - hyst:
                        switch1 = True
                    else:
                        switch1 = WH.switch1
                    if T_probe2 >= T_SP:
                        switch2 = False
                    elif T_probe2 <= T_SP - hyst:
                        switch2 = True
                    else:
                        switch2 = WH.switch2
                    if switch1 == True and switch2 == True: 
                        switch1 = False
                        
                elif WH.Model == 'random_E':   
                    T_probe = T_probe[0]
                    if T_probe >= T_SP:
                        switch1 = False
                    elif T_probe <= T_SP - hyst:
                        switch1 = True
                    else:
                        switch1 = WH.switch1
                    switch2 = False
                    
                else:
                    T_probe = T_probe[0]
                    if T_probe >= T_SP:
                        switch2 = False
                    elif T_probe <= T_SP - hyst:
                        switch2 = True
                    else:
                        switch2 = WH.switch2
                    switch1 = False
                    if T_probe > self.T_max_HP:
                        switch2 = False

            else: 
                switch1 = False
                switch2 = False
                    
        if strategy ==  'full_load': # Use the full power available to heat until the maximum temperature allowed (self.T_max)
            T_max = self.T_max
            hyst = 5 #K 
            if WH.Model == 'VELIS':
                T_probe1 = T_probe[0]
                T_probe2 = T_probe[1]
                if T_probe1 >= T_max:
                    switch1 = False
                elif T_probe1 <= T_max - hyst:
                    switch1 = True
                else:
                    switch1 = WH.switch1
                if T_probe2 >= T_max:
                    switch2 = False
                elif T_probe2 <= T_max - hyst:
                    switch2 = True
                else:
                    switch2 = WH.switch2
                    
            elif WH.Model == 'random_E':   
                T_probe = T_probe[0]
                if T_probe >= T_max:
                    switch1 = False
                elif T_probe <= T_max - hyst:
                    switch1 = True
                else:
                    switch1 = WH.switch1
                switch2 = False
                
            else:
                T_probe = T_probe[0]
                if T_probe >= T_max:
                    switch2 = False
                elif T_probe <= T_max - hyst:
                    switch2 = True
                else:
                    switch2 = WH.switch2
                switch1 = switch2
                if T_probe > self.T_max_HP:
                    switch2 = False
        return switch1, switch2
        
    def plot_available_storage(self): 
        """
        Plot the power that could be used instantly and the reserve of elecricity that can be stored.

        Returns
        -------
        None.
        
        """

        xdim = 5.5+1
        ydim = 4.3
        labelsize = 18
        N_max = np.round(self.time_vect_com[-1]/3600)
        
        ## plot
        plt.figure(figsize=(xdim,ydim),constrained_layout=True)
        plt.rcParams.update({'font.size':16})
        params = {
                  "text.usetex" : True,
                  "font.family" : "cm"}
        plt.rcParams.update(params)
    
        ax1 = plt.subplot(2,1,1)
        plt.grid()

        plt.plot(self.time_vect_com/3600, self.P_sto_vect - self.P_vect_cum/1000, 'k', linewidth = 1.5)


     
        plt.xlabel('Time [h]',fontsize=18,  fontname="Times New Roman")
        plt.ylabel('$\dot{W}_{el,sto}$ [kW]',fontsize=labelsize, fontname="Times New Roman" )            
        plt.xlim(0, N_max)
        plt.xticks(np.arange(0,N_max+1,4*N_max//24))
        
        ax2 = plt.subplot(2,1,2)
        plt.grid() 
        plt.plot(self.time_vect_com/3600, self.E_sto_vect , 'k',  linewidth = 1.5)
        
        plt.xlabel('Time [h]',fontsize=18,  fontname="Times New Roman")
        plt.ylabel('$E_{el,sto}$ [kWh]',fontsize=labelsize, fontname="Times New Roman" )   
        plt.xlim(0, N_max)
        plt.xticks(np.arange(0,N_max+1,4*N_max//24))
        
        
    def plot_consumption(self): 
        """
        Create two plots.
        Plot the electricity consumption profile of all water heaters AND the cumulated electricity consumption as a function of time.
        Plot the cumulated water use AND the cumulated electricity consumption as a function of time.
        Returns
        -------
        None.

        """

        xdim = 5.5+1
        ydim = 4.3
        labelsize = 18
        N_max = np.round(self.time_vect_com[-1]/3600)
        
        ## plot -- all profiles + total consumption 
        plt.figure(figsize=(xdim,ydim),constrained_layout=True)
        plt.rcParams.update({'font.size':16})
        params = {
                  "text.usetex" : True,
                  "font.family" : "cm"}
        plt.rcParams.update(params)
    
        ax1 = plt.subplot(2,1,1)
        plt.grid()
        for i in range(len(self.P_el_mat[0])): 
            plt.plot(self.time_vect_com/3600, self.P_el_mat[:,i] , 'k', linewidth = 0.5)


     
        plt.xlabel('Time [h]',fontsize=18,  fontname="Times New Roman")
        plt.ylabel('$\dot{W}_{el,i}$ [W]',fontsize=labelsize, fontname="Times New Roman" )            
        plt.xlim(0, N_max)
        plt.xticks(np.arange(0,N_max+1,4*N_max//24))
        
        ax2 = plt.subplot(2,1,2)
        plt.grid() 
        plt.plot(self.time_vect_com/3600, np.array(self.P_vect_cum)/1000 , 'k',  linewidth = 2)
        
        plt.xlabel('Time [h]',fontsize=18,  fontname="Times New Roman")
        plt.ylabel('$\sum \dot{W}_{el,i}$ [kW]',fontsize=labelsize, fontname="Times New Roman" )   
        plt.xlim(0, N_max)
        plt.xticks(np.arange(0,N_max+1,4*N_max//24))

        ## plot -- water consumption over time + total electricity consumption 
        plt.figure(figsize=(xdim,ydim),constrained_layout=True)
        plt.rcParams.update({'font.size':16})
        params = {
                  "text.usetex" : True,
                  "font.family" : "cm"}
        plt.rcParams.update(params)
    
        ax1 = plt.subplot(2,1,1)
        plt.grid()

        plt.plot(self.time_vect_com/3600, np.array(self.V_dot_vect_cum )*60, 'k', linewidth = 1.5)


     
        plt.xlabel('Time [h]',fontsize=18,  fontname="Times New Roman")
        plt.ylabel('$\sum \dot{V}_{w,i}$ [l/min]',fontsize=labelsize, fontname="Times New Roman" )           
        plt.xlim(0, N_max )
        plt.xticks(np.arange(0,N_max+1,4*N_max//24))
        
        ax2 = plt.subplot(2,1,2)
        plt.grid() 
        plt.plot(self.time_vect_com/3600, np.array(self.P_vect_cum)/1000 , 'k',  linewidth = 1.5)
        
        plt.xlabel('Time [h]',fontsize=18,  fontname="Times New Roman")
        plt.ylabel('$\sum \dot{W}_{el,i}$ [kW]',fontsize=labelsize, fontname="Times New Roman" )   
        plt.xlim(0, N_max)
        plt.xticks(np.arange(0,N_max+1,4*N_max//24))        
        

 
    def correct_flow_rate(self, V_dot_h, T_out_wh):
        """
        The hot water volumetric flow rate generated stochastically is based on a temperature of 50°C
        If the water temperature is different from 50°C, the volumetric flow rate is going to be different,
        as the thermostatic valve (from the tap, shower,...) increases/drecreases automatically the opening
        of the hot water passage

        Parameters
        ----------
        V_dot_h : float
            Volumetric flow rate (unit not important).
        T_out_wh : float
            Outlet water temperature of the water heater.

        Returns
        -------
        V_dot_h_new : float
            Corrected volumetric flow rate (same unit as the inpuy).
        """
        
        # Constant density assumed whatever the temperature
        
        T_hot = 50 + 273.15 # K
        T_cold = self.T_w_supply
        T_constraint = self.T_constraint
        V_dot_tot = (T_hot - T_cold)/(T_constraint - T_cold)*V_dot_h
        
        V_dot_h_new = V_dot_h * (T_hot - T_cold)/(T_out_wh - T_cold)
        
        if T_out_wh <= T_constraint: # the constraint temperature is never gonna be reached --> maximum flow rate achieveable
            V_dot_h_new = V_dot_tot
            
        return V_dot_h_new
    
    def E_storage_potential(self):
        """
        Function to compute the energy storage potential of the pool as well as the available power that can be stored

        Returns
        -------
        P_sto : float
            Available electric power in kW (using the heating resistor for the HP as well).
        E_sto : float
            Available energy storage in kWh.

        """

        P_sto = 0
        E_sto = 0 
        T_max = self.T_max
        cp = 4186 #J/(kgK)
        
        # Loop over the pool of water heaters
        for WH in self.pool_WH:
            if WH.Model == 'VELIS':
                P_resistor = WH.param_heating['Q_dot_peak_E']*2
                T_mean = np.mean([WH.T_record1[-1] , WH.T_record2[-1]])
                P_HP = 0
            elif WH.Model == 'random_E':
                P_resistor = WH.param_heating['Q_dot_peak_E']
                T_mean = np.mean(WH.T_record1[-1])
                P_HP = 0
            else:
                P_resistor = WH.param_heating['Q_dot_peak_E']
                T_mean = np.mean(WH.T_record1[-1])
                P_HP, Q_dot_cd, _ = WH.HP_cycle(WH.T_record1[-1], True, self.T_ext)
            

            E_sto_wh = WH.Total_volume*1000 * cp * (T_max - T_mean)
            E_sto += E_sto_wh
            P_sto =  P_sto + P_resistor + P_HP
        
        P_sto = P_sto/1000 # kW        
        E_sto = E_sto/3.6/1e6 # kWh

        return  P_sto, E_sto 

    def save_results_csv(self, name):
        """
        Save the results of the simulation in two csv files. 
        The file with the extension "charact" gives the parameters of each water heater of the pool.
        The file with the extension "time_series" gives the variables (electrical consumption, water consumption,...)
        of each water heater varying with time.

        Parameters
        ----------
        name : string
            Name of the files that are going to be saved.

        Returns
        -------
        None.

        """
        
        # Get the unique filename from the file_name_csv function
        filename_charact, filename_timeseries = procF.wh.file_name_csv(name)
 
        # Construct the full path to save the CSV - 
        full_path_charact = os.path.join('..', 'data', 'Simulations', filename_charact)
        full_path_timeseries = os.path.join('..', 'data', 'Simulations', filename_timeseries)
 
        # Create the data dictionary
        data = {
            'time_seconds': self.time_vect_com,
            'cumulated_power_kW': np.array(self.P_vect_cum) / 1000,
            'cumulated_flow_lps': self.V_dot_vect_cum,
            'storage_available_kWh': self.E_sto_vect,
            'power_available_kW': self.P_sto_vect - self.P_vect_cum/ 1000
        }
        
 
        # Reset index for the next loop
        i = 0
        for WH in self.pool_WH:
            data[f'vdot_{i}_lps'] = WH.flow_rate_lps
            i += 1
 
        # Reset index for the next loop
        i = 0
        for WH in self.pool_WH:
            data[f'W_dot_el_{i}_W'] = self.P_el_mat[:,i]
            i += 1
 
        # Reset index for the next loop
        i = 0
        for WH in self.pool_WH:
            data[f'T_mean_{i}_W'] = self.T_mean_mat[:,i]
            i += 1

        # Create a new disctionnary for the characteristics of each water heater 
        data_charact = {'Water Heater': [], 'Type': [], 'Volume (L)' : [], 'Electric Power (W)' : [], 'Height (m)' : [], 'Diameter (m)' : [] }
        # Initialize the index for water heaters
        i = 0
        for WH in self.pool_WH:
            data_charact['Water Heater'].append(f'Water_heater_{i}')
            data_charact['Type'].append(WH.Model)
            data_charact['Volume (L)'].append(WH.Volume * 1000)
            data_charact['Electric Power (W)'].append(WH.param_heating['Q_dot_peak_E'])
            data_charact['Height (m)'].append(WH.Height)
            data_charact['Diameter (m)'].append(WH.Diameter)
            i += 1

        # Create a DataFrames from the dictionaries
        df_charact = pd.DataFrame(data_charact)
        df_timeseries = pd.DataFrame(data)
 
        # Save the DataFrame to the specified path
        df_charact .to_csv(full_path_charact, index=False, sep=';')
        df_timeseries.to_csv(full_path_timeseries, index=False, sep=';')
        print(f"Results saved to {full_path_charact} and {full_path_timeseries}")        
    
        
        
        
        
        