import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from scipy.interpolate import make_interp_spline
from scipy.stats import norm
import math
import random
# include the main library path (the parent folder) in the path environment variable
import os,sys
root_folder = os.path.dirname(os.path.dirname(os.path.realpath(__file__)))
sys.path.append(root_folder)
# import the library as a package (defined in __init__.py) => function calls are done through the lpackage (eg om.solve_model)
import source as procF


class WaterHeaterPool():
    """
    Class to create a pool of water heater and simulate it's electricity 
    consumption under diverse water consumption profiles generated by a function of the class
    """
    def __init__(self, N_random_HP = 10, N_random_E = 10, N_VELIS = 0, N_NUOS = 0):
        
        """
        Initilization of the pool
        Parameters
        ----------
        N_random_HP : number of Heat Pumps generated with random dimensions 
        N_random_E : number of electrical water heater generated with random dimensions 
        N_VELIS : number of Velis Electrical water heater generated
        N_NUOS : number of Nuos Electrical water heater generated
        """    
                
        self.N_random_HP = N_random_HP
        self.N_random_E = N_random_E
        self.N_VELIS = N_VELIS
        self.N_NUOS = N_NUOS
        
        # discretization of the pool
        self.nx = 40 # 40 usually
        self.T_SP_normal = 55 + 273.15  
        self.T_SP_velis = 70 + 273.15  
        self.T_init = self.T_SP_normal 
        self.T_init_Velis = self.T_SP_velis 
        self.tau_charge = 60 # seconds # time step for a charge
        self.tau_discharge = 2 # seconds # time step for a discharge (must be a divider of 60 !!)
        self.T_constraint = 38 + 273.15 # K
        self.T_max = 90 + 273.15
        self.T_max_HP = 55 + 273.15 # maximum temperature until which the heat pump is working
        
        # Control strategy 
        # 'mid_day_night' - 'tracking_SP' - 'full_load'
        self.pool_control_strategy = 'tracking_SP'
        
        # Ground water temperature at 14°C (avg in BE) --> can be modified to vary over the course of the year
        self.T_w_supply = 14 + 273.15
        
        # Ambient temperature assumed as being 19°C --> can be modified to vary over the course of the year
        self.T_amb = 19 + 273.15
        self.T_ext = 19 + 273.15 # for the heat pump 
        
        self.pool_WH = []
        
        # Pre-defined Water heater parameters
        self.VELIS_params = {
        'model': 'VELIS',
        'double': True,
        'diameter': 0.21,  # m
        'height': 0.93,    # m
        'volume' : None,
        'HPWH' : False,
        'EWH' : True,
        'z_control' : 0.3,
        'z_init_E' : 0.0,
        'z_init_HP' : 0.0,
        'height_HP' : 0.0,
        'height_E' : 0.3,
        'Q_dot_peak_E' : 1250,
        'h_amb' : 0.84,
        'H_mix' : 0.15,
        'V_s' : 0,
        'W_dot_el_basis' : 0
        }
        
        self.NUOS_params = {
        'model': 'NUOS',
        'double': False,
        'diameter': 0.419,  # m
        'height': 1.09,    # m
        'volume' : None,
        'HPWH' : True,
        'EWH' : True,
        'z_control' : 0.29,
        'z_init_E' : 0.0,
        'z_init_HP' : 0.05,
        'height_HP' : 0.25,
        'height_E' : 0.16,
        'Q_dot_peak_E' : 1200,
        'h_amb' : 0.7,
        'H_mix' : 0.2,
        'V_s' : 5/1e6,
        'W_dot_el_basis' : 100
        }   
        
        self.Random_HP_params = {
        'model' : 'random_HP',
        'diameter': None,  
        'double': False,
        'HPWH' : True,
        'EWH' : True,
        'z_control' : 0.3,
        'z_init_E' : 0.0,
        'z_init_HP' : 0.05,
        'height_HP' : 0.3,
        'height_E' : 0.2,
        'h_amb' : 0.75,
        'H_mix' : 0.15,
        'W_dot_el_basis' : 100
        }
        
        self.Random_E_params = {
        'model' : 'random_E',
        'diameter': None,  
        'double': False,
        'EWH' : True,  
        'HPWH' : False,
        'z_control' : 0.3,
        'z_init_E' : 0.0,
        'z_init_HP' : 0.0,
        'height_HP' : 0.0,
        'height_E' : 0.3,
        'h_amb' : 0.75,
        'H_mix' : 0.15,
        'V_s' : 0,
        'W_dot_el_basis' : 0
        }
            
    def DHW_load_gen(self, nday, day_init = 0, bool_plot = False):
        
        
        """
        Create a water consumption profile starting at day day_init and stopping after nday.
        Return the water mass flow 
        
        %References
        
        %[1] Hendron, R., Burch, J., Barker, G. 2010. Tool for generating realistic
        %residential hot water event schedules. Proceedings of the Fourth National Conference of
        %IBPSA-USA, Simbuild 2010, New York City, USA.
        
        %[2] Hendron, R., Engebrecht, C. 2010. Building America Research Benchmark
        %Definition: Updated December 2009. NREL Report No TP-550-47246. Golden,
        %CO:NREL
        
        %[3] Spur, R., Fiala, D., Nevrala, D., Probert, D. 2006. Influence of the
        %domestic hot-water daily draw-off profile on the performance of a
        %hot-water store. Applied Energy, 83 pp.749-773.
        
        %[4] Jordan, U., Vajen, K. 2001. Realistic Domestic Hot-Water Profiles in
        %Different Time Scales. IEA-SHC Task 26 report, May 2001.
        """
        
        # Fraction of Daily Usage [2]
        # Adjustment of the chance factors to get 50L/day/pers at 50 °C + (2x more sink A than sinkB, 8 times more shower than bath + 80/20% bathroom/kitchen load)
        f_daily_sinkA = 1.6*1/3.5*1/6
        f_daily_sinkB = 1.6*f_daily_sinkA*1/6
        f_daily_shwr = 0.85*1/2*1/30
        f_daily_bath = 0.85*1/4*1/400

        probday_shwr = [0.011, 0.005, 0.003, 0.005, 0.014, 0.052, 0.118, 0.117, 0.095, 0.074, 0.060, 0.047, 0.034, 0.029, 0.025, 0.026, 0.030, 0.039, 0.042, 0.042, 0.042, 0.041, 0.029, 0.021]
        probday_bath = [0.008, 0.004, 0.004, 0.004, 0.008, 0.019, 0.046, 0.058, 0.066, 0.058, 0.046, 0.035, 0.031, 0.023, 0.023, 0.023, 0.039, 0.046, 0.077, 0.100, 0.100, 0.077, 0.066, 0.039]
        probday_sink = [0.014, 0.007, 0.005, 0.005, 0.007, 0.018, 0.042, 0.062, 0.066, 0.062, 0.054, 0.050, 0.049, 0.045, 0.041, 0.043, 0.048, 0.065, 0.075, 0.069, 0.057, 0.048, 0.040, 0.027]
        
        if bool_plot == True:
            # Plot the distribution
            time_vect = np.arange(0,24,1)
    
            # Creating a smoother curve using spline interpolation
            time_new = np.linspace(time_vect.min(), time_vect.max(), 300)  # 300 points for smooth curve
            spl_shwr = make_interp_spline(time_vect, probday_shwr, k=2)
            probday_shwr_smooth = spl_shwr(time_new)
            spl_bath = make_interp_spline(time_vect, probday_bath, k=2)
            probday_bath_smooth = spl_bath(time_new)
            spl_sink = make_interp_spline(time_vect, probday_sink, k=2)
            probday_sink_smooth = spl_sink(time_new)
            
            
            plt.figure(figsize=(4,3),constrained_layout=True)
            plt.rcParams.update({'font.size':16})
            params = {
                       "text.usetex" : True,
                       "font.family" : "cm"}
            plt.rcParams.update(params)
            plt.grid()
            plt.plot(time_new, probday_shwr_smooth , 'b', linewidth = 2, label = 'Shower')
            plt.plot(time_new, probday_bath_smooth , 'r', linewidth = 2, label = 'Bath')
            plt.plot(time_new, probday_sink_smooth , 'g',  linewidth = 2 , label = 'Sink')
            plt.xlabel('Time [hour]', fontsize=16,  fontname="Times New Roman")
            plt.ylabel('Probability [-]', fontsize=16, fontname="Times New Roman")       
            plt.legend(fontsize=12, loc='best')  
        
        
        # Characteristics [3] & [4]
        # A: short draw-off; B:medium draw-off; C:shower; D:bath
        V_dot_A_m = 1/60/1000 #m^3/s
        V_dot_B_m = 2/60/1000 #m^3/s
        V_dot_C_m = 8/60/1000 #m^3/s
        V_dot_D_m = 14/60/1000 #m^3/s
        
        V_dot_A_std = 1/60/1000 #m^3/s
        V_dot_B_std = 1/60/1000 #m^3/s
        V_dot_C_std = 2/60/1000 #m^3/s
        V_dot_D_std = 2/60/1000 #m^3/s
        
        DELTAt_A_m = 1*60 #sec
        DELTAt_B_m = 1*60 #sec
        DELTAt_C_m = 5*60 #sec
        DELTAt_D_m = 10*60 #sec
        
        DELTAt_A_std = 0.5*60 #sec
        DELTAt_B_std = 0.5*60 #sec
        DELTAt_C_std = 2.5*60 #sec
        DELTAt_D_std = 5*60 #sec


        #Time
        ti = day_init*24*60
        DELTAtmin = 1
        tf = ti + nday*24*60/DELTAtmin
        nstep = int(nday*24*60/DELTAtmin)

        # Variables
        minweek = np.zeros(nstep, dtype = int) # minutes of the week (reset after 10080)
        fsinkA = np.zeros(nstep) #boolean to check activation of event sinkA
        fsinkB = np.zeros(nstep) #boolean to check activation of event sinkB
        fshwr = np.zeros(nstep) #boolean to check activation of event fshwr
        fbath = np.zeros(nstep) #boolean to check activation of event fbath
        V_dot_sinkA = np.zeros(nstep) # volume flow rate of type sinkA for the whole period
        V_dot_sinkB = np.zeros(nstep) # volume flow rate of type sinkB for the whole period
        V_dot_shwr = np.zeros(nstep) # volume flow rate of type shower for the whole period
        V_dot_bath = np.zeros(nstep) # volume flow rate of type bath for the whole period
        V_dot_tot = np.zeros(nstep)  #  total volume flow rate of type sinkA for the whole period
        V_dot_tot_lmin = np.zeros(nstep) #  total volume flow rate of type sinkA for the whole period in l/min
        n_sinkA = np.zeros(nday) #  number of type sinkA occurence per day
        n_sinkB = np.zeros(nday) #  number of type sinkB occurence per day
        n_shwr = np.zeros(nday) #  number of type shower occurence per day
        n_bath = np.zeros(nday) #  number of type bath occurence per day
        t_sinkA = np.zeros(nday) # total time of type sinkA per day 
        t_sinkB = np.zeros(nday) # total time of type sinkb per day 
        t_shwr = np.zeros(nday) # total time of type shower per day 
        t_bath = np.zeros(nday) # total time of type bath per day 
        V_sinkA_lit = np.zeros(nday) # total volume of type sinkA in liters per day 
        V_sinkB_lit = np.zeros(nday) # total volume of type sinkA in liters per day 
        V_shwr_lit = np.zeros(nday) # total volume of type sinkA in liters per day 
        V_bath_lit = np.zeros(nday) # total volume of type sinkA in liters per day 
        self.V_tot_lit = np.zeros(nday) # total volume in liters per day 
        V_tot_lit_yr = np.zeros(int(np.ceil(nday/365))) # total volume per year 


        flowAmat = np.zeros((int(7*24*60/DELTAtmin), int(np.ceil(nday/7))))
        flowBmat = np.zeros((int(7*24*60/DELTAtmin), int(np.ceil(nday/7))))
        flowCmat = np.zeros((int(7*24*60/DELTAtmin), int(np.ceil(nday/7))))
        flowDmat = np.zeros((int(7*24*60/DELTAtmin), int(np.ceil(nday/7))))
        
        fAmat = np.zeros((int(7*24*60/DELTAtmin), int(np.ceil(nday/7))))
        fBmat = np.zeros((int(7*24*60/DELTAtmin), int(np.ceil(nday/7))))
        fCmat = np.zeros((int(7*24*60/DELTAtmin), int(np.ceil(nday/7))))
        fDmat = np.zeros((int(7*24*60/DELTAtmin), int(np.ceil(nday/7))))


        # Initialize indexes
        fA = 0 
        fAprev = 0
        iA = -1
        jA = -1
        flowA = 0
        fB = 0 
        fBprev = 0
        iB = -1
        jB = -1
        flowB = 0
        fC = 0 
        fCprev = 0
        iC = -1
        jC = -1
        flowC = 0
        fD = 0 
        fDprev = 0
        iD = -1
        jD = -1
        flowD = 0
        
        # Initialize random variable lists + starting time vector
        bA = []
        bB = []
        bC = []
        bD = []
        cA = []
        cB = []
        cC = []
        cD = []
        tstartA = []
        tstartB = []
        tstartC = []
        tstartD = []
        tendA = []
        tendB = []
        tendC = []
        tendD = []

        cumprobdurA = norm.cdf(np.arange(0, 2400), loc = DELTAt_A_m, scale = DELTAt_A_std) # in second 
        cumprobdurB = norm.cdf(np.arange(0, 2400), loc = DELTAt_B_m, scale = DELTAt_B_std)
        cumprobdurC = norm.cdf(np.arange(0, 2400), loc = DELTAt_C_m, scale = DELTAt_C_std)
        cumprobdurD = norm.cdf(np.arange(0, 2400), loc = DELTAt_D_m, scale = DELTAt_D_std)

        # Model [4]
            
        for t in np.arange(int(ti), int(tf)):

            hour = t/60
            # Hour of the day (1-24)
            hourday = (hour % 24)
            
            day = t / (24 * 60)
            dayi = int(np.floor(day))
            
            # Day of the week (1-7)
            dayweek = (day %  7)
            
            # day of the year (1-365)
            dayyr = day % 365

            
            # Year
            yr = t / (24 * 60 * 365)
            yri = int(np.floor(yr))
            
            # Minute of the week
            # Create a list or array to hold minweek values, assuming t is an integer
            # minweek = np.zeros(t+1)  # Pre-allocate space
            minweek[t] = t % (7 * 24 * 60)
            # Week of the year
            week = t / (24 * 60 * 7)
            weeki = int(np.floor(week))

            # probseason - Course of probabilities during the year
            P = 365*24*60
            A = 0.1
            B = - 61.75*24*60
            probseason = 1 + A*np.sin(2*np.pi*(t - B)/DELTAtmin*1/P)
            # probweek - Course of probabilities during the week (variable probability for taking a bath)
            probweekA = 1
            probweekB = 1
            probweekC = 1
            if dayweek <= 4:
                probweekD = 0.5
            elif dayweek > 4 and dayweek <= 5:
                probweekD = 0.8
            elif dayweek > 5 and dayweek <= 6:
                probweekD = 1.9
            elif dayweek > 6 and dayweek <= 7:
                probweekD = 2.3
            
            # probday - Daily distribution of probabilities
            probdayA = probday_sink[math.trunc((hourday))]
            probdayB = probday_sink[math.trunc((hourday))]
            probdayC = probday_shwr[math.trunc((hourday))]
            probdayD = probday_bath[math.trunc((hourday))]
            
            
            
            # probholiday - Holiday period
            if (dayyr >= 195 and dayyr <= 208) or (dayyr >= 220 and dayyr <= 233):
                probholiday = 0.5
            else:
                probholiday = 1
            
            # probyear - Global probability function
            probyearA = f_daily_sinkA * probseason * probweekA * probdayA * probholiday
            probyearB = f_daily_sinkB * probseason * probweekB * probdayB * probholiday
            probyearC = f_daily_shwr * probseason * probweekC * probdayC * probholiday
            probyearD = f_daily_bath * probseason * probweekD * probdayD * probholiday
            
            
            # Stochastic process
            if t < 1:
                fsinkA[t] = 0
                fsinkB[t] = 0
                fshwr[t] = 0
                fbath[t] = 0
                V_dot_sinkA[t] = 0
                V_dot_sinkB[t] = 0
                V_dot_shwr[t] = 0
                V_dot_bath[t] = 0

            else:
                aA = random.random()
                aB = random.random()
                aC = random.random()
                aD = random.random()
                # Is appliance (water use case A) already functioning ?
                if fAprev == 0: #NO
                    # Stochastic process to determine if an operation cycle (use of water from case A) is starting
                    if aA < probyearA: # process is starting 
                        iA = iA + 1
                        fA = 1
                        tstartA.append(t)
                        bA.append(random.random()) #duration probability index
                        cA.append(max(0, np.random.normal(V_dot_A_m, V_dot_A_std))) # pick-up flow
                        flowA = cA[iA]
                    else: # Nothing is starting
                        fA = 0
                        flowA = 0
                    
                    # Is appliance already functioning ?
                else: #YES
                    # What is the duration of the on-going cycle ?
                    DELTAtonA = max(0,(t-tstartA[iA]))
                    # print(bA[iA], cumprobdurA[DELTAtonA*60], tstartA[iA], t)
                    if bA[iA] < cumprobdurA[DELTAtonA*60]:
                        #Cycle stops
                        jA = jA + 1
                        tendA.append(t)
                        fA = 0
                        flowA = 0
                    else: # cycle continue 
                        fA = 1
                        flowA = cA[iA]
                    
                fAprev = fA
                # Is appliance (water use case B) already functioning ?
                if fBprev == 0: #NO
                    # Stochastic process to determine if an operation cycle (use of water from case A) is starting
                    if aB < probyearB: # process is starting 
                        iB = iB + 1
                        fB = 1
                        tstartB.append(t)
                        bB.append(random.random()) #duration probability index
                        cB.append(max(0, np.random.normal(V_dot_B_m, V_dot_B_std))) # pick-up flow
                        flowB = cB[iB]
                    else: # Nothing is starting
                        fB = 0
                        flowB = 0
                    
                    # Is appliance already functioning ?
                else: #YES
                    # What is the duration of the on-going cycle ?
                    DELTAtonB = max(0,(t-tstartB[iB]))
                    if bB[iB] < cumprobdurB[DELTAtonB*60]:
                        #Cycle stops
                        jB = jB + 1
                        tendB.append(t)
                        fB = 0
                        flowB = 0
                    else: # cycle continue 
                        fB = 1
                        flowB = cB[iB]
                    
                fBprev = fB
                # Is appliance (water use case C) already functioning ?
                if fCprev == 0: #NO
                    # Stochastic process to determine if an operation cycle (use of water from case A) is starting
                    if aC < probyearC: # process is starting 
                        iC = iC + 1
                        fC = 1
                        tstartC.append(t)
                        bC.append(random.random()) #duration probability index
                        cC.append(max(0, np.random.normal(V_dot_C_m, V_dot_C_std))) # pick-up flow
                        flowC = cC[iC]
                    else: # Nothing is starting
                        fC = 0
                        flowC = 0
                    
                    # Is appliance already functioning ?
                else: #YES
                    # What is the duration of the on-going cycle ?
                    DELTAtonC = max(0,(t-tstartC[iC]))
                    if bC[iC] < cumprobdurC[DELTAtonC*60]:
                        #Cycle stops
                        jC = jC + 1
                        tendC.append(t)
                        fC = 0
                        flowC = 0
                    else: # cycle continue 
                        fC = 1
                        flowC = cC[iC]
                    
                fCprev = fC
                # Is appliance (water use case D) already functioning ?
                if fDprev == 0: #NO
                    # Stochastic process to determine if an operation cycle (use of water from case A) is starting
                    if aD < probyearD: # process is starting 
                        iD = iD + 1
                        fD = 1
                        tstartD.append(t)
                        bD.append(random.random()) #duration probability index
                        cD.append(max(0, np.random.normal(V_dot_D_m, V_dot_D_std))) # pick-up flow
                        flowD = cD[iD]
                    else: # Nothing is starting
                        fD = 0
                        flowD = 0
                    
                    # Is appliance already functioning ?
                else: #YES
                    # What is the duration of the on-going cycle ?
                    DELTAtonD = max(0,(t-tstartD[iD]))
                    if bD[iD] < cumprobdurD[DELTAtonD*60]:
                        #Cycle stops
                        jD = jD + 1
                        tendD.append(t)
                        fD = 0
                        flowD = 0
                    else: # cycle continue 
                        fD = 1
                        flowD = cD[iD]
                    
                fDprev = fD
                
            # flow (m3/s to liters/s)
            flowA = flowA*1000
            flowB = flowB*1000
            flowC = flowC*1000
            flowD = flowD*1000
            flowtot = flowA + flowB + flowC + flowD
            
            # min*week matrix
            flowAmat[minweek[t], weeki] = flowA
            flowBmat[minweek[t], weeki] = flowB
            flowCmat[minweek[t], weeki] = flowC
            flowDmat[minweek[t], weeki] = flowD
        
            V_dot_sinkA[t] = flowA #l/s
            V_dot_sinkB[t] = flowB
            V_dot_shwr[t] = flowC
            V_dot_bath[t] = flowD
            V_dot_tot[t] = flowtot
            V_dot_tot_lmin[t] = flowtot*60
            
            #DHW use
            fsinkA[t] = fA
            fsinkB[t] = fB
            fshwr[t] = fC
            fbath[t] = fD
        
            fAmat[minweek[t], weeki] = fA
            fBmat[minweek[t], weeki] = fB
            fCmat[minweek[t], weeki] = fC
            fDmat[minweek[t], weeki] = fD
            
            #Daily data
            #Events occurence
            if dayi == 0:
                n_sinkA[dayi] = iA
                n_sinkB[dayi] = iB
                n_shwr[dayi] = iC
                n_bath[dayi] = iD
            else:
                n_sinkA[dayi] = iA - sum(n_sinkA[:dayi])
                n_sinkB[dayi] = iB - sum(n_sinkB[:dayi])
                n_shwr[dayi] = iC - sum(n_shwr[:dayi])
                n_bath[dayi] = iD - sum(n_bath[:dayi])

            
            # Events duration in minutes
            t_sinkA[dayi] = t_sinkA[dayi] + fA
            t_sinkB[dayi] = t_sinkB[dayi] + fB
            t_shwr[dayi] = t_shwr[dayi] + fC
            t_bath[dayi] = t_bath[dayi] + fD
            
            # Events volume in liters
            V_sinkA_lit[dayi] = V_sinkA_lit[dayi] + flowA*DELTAtmin*60
            V_sinkB_lit[dayi] = V_sinkB_lit[dayi] + flowB*DELTAtmin*60
            V_shwr_lit[dayi] = V_shwr_lit[dayi] + flowC*DELTAtmin*60
            V_bath_lit[dayi] = V_bath_lit[dayi] + flowD*DELTAtmin*60
            self.V_tot_lit[dayi] = V_sinkA_lit[dayi] + V_sinkB_lit[dayi] + V_shwr_lit[dayi] + V_bath_lit[dayi]
            
            # Annual volume in liters
            V_tot_lit_yr[yri] = V_tot_lit_yr[yri] + flowtot*DELTAtmin*60
            
        # Average daily usage
        
        # Total daily volume
        self.V_tot_davg_lit = np.mean(self.V_tot_lit)
        V_sinkA_davg_lit = np.mean(V_sinkA_lit)
        V_sinkB_davg_lit = np.mean(V_sinkB_lit)
        V_shwr_davg_lit = np.mean(V_shwr_lit)
        V_bath_davg_lit = np.mean(V_bath_lit)
        
        # Daily time of use (minutes)
        t_sinkA_davg = np.mean(t_sinkA)
        t_sinkB_davg = np.mean(t_sinkB)
        t_shwr_davg = np.mean(t_shwr)
        t_bath_davg = np.mean(t_bath)
        
        # Daily number of occurrences
        n_sinkA_davg = np.mean(n_sinkA)
        n_sinkB_davg = np.mean(n_sinkB)
        n_shwr_davg = np.mean(n_shwr)
        n_bath_davg = np.mean(n_bath)
        
        V_tot_litsecond = V_dot_tot
        
        
        return V_tot_litsecond
        
    def generate_WH(self):   
        """
        Generate the pool of water heater
        Able to create random electric water heaters or heat pump water heater
        Able to create a Velis Electrical Water heater or a Nuos Heat pump water 
        heater (based on validated parameters)
        
        The water heaters (class) are gathered in a list called self.pool_WH
        
        Nothing returned
        """
        V_range = [120/1e3, 150/1e3, 180/1e3, 210/1e3, 250/1e3, 280/1e3] # range of volumes to be picked up from
        Power_range = [2000, 2200, 2400, 2600, 2800, 3000] # W for EWH
        Power_assist_range = [500, 750, 1000, 1250, 1500, 1750] # W to assist the heat pump
        V_s_range = [3/1e6, 5/1e6, 7/1e6, 9/1e6, 11/1e6, 13/1e6]
        height_mean = 1 # m
        height_std = 0.2 # m 
        
        
        # Velis water heater
        for i in range(self.N_VELIS):
            WH = self.create_WH(self.VELIS_params)
            self.pool_WH.append(WH) 
        
        # Nuos water heater    
        for i in range(self.N_NUOS):
            WH = self.create_WH(self.NUOS_params)
            self.pool_WH.append(WH) 
        
        # Random electrical water heater
        for i in range(self.N_random_E):
            # generate random dimensions/characteristics
            volume = random.choice(V_range)
            height = np.random.normal(height_mean, height_std)
            # power = random.choice(Power_range)
            power = Power_range[np.where(np.array(V_range) == volume)[0][0]]
            
            # add the dimensions/characteristics to the parameter dictionary 
            self.Random_E_params['volume'] = volume
            self.Random_E_params['height'] = height
            self.Random_E_params['Q_dot_peak_E'] = power
            
            # Creation of the water heater and inclusion in the pool
            WH = self.create_WH(self.Random_E_params)
            self.pool_WH.append(WH) 
         
        # Random heat pump water heater   
        for i in range(self.N_random_HP):
            # generate random dimensions/characteristics
            volume = random.choice(V_range)
            height = np.random.normal(height_mean, height_std)
            power_el_assist = random.choice(Power_assist_range)
            # V_s = random.choice(V_s_range)
            V_s = V_s_range[np.where(np.array(V_range) == volume)[0][0]]
            
            # add the dimensions/characteristics to the parameter dictionary 
            self.Random_HP_params['volume'] = volume
            self.Random_HP_params['height'] = height
            self.Random_HP_params['Q_dot_peak_E'] = power_el_assist
            self.Random_HP_params['V_s'] = V_s
            
            # Creation of the water heater and inclusion in the pool
            WH = self.create_WH(self.Random_HP_params)
            self.pool_WH.append(WH) 


    def create_WH(self, params): 
        """
        Create a water heater (class) using the set of given parameters 
        Initiate the class using wh.procF.WaterHeater
        Create the heating system based on the parameters provided in the input params (given in the generate_WH function)
        Add the model parameters also based on the input params 
        
        Return the waterheater class 
        """
        # Model creation
        WH = procF.wh.WaterHeater(Model = params['model'], Volume = params['volume'], Height = params['height'], Diameter = params['diameter'], EWH = params['EWH'], HPWH = params['HPWH'], double = params['double'])    
        # Definition of the heating system geometry
        WH.Heating_system(z_control = params['z_control'], z_init_E = params['z_init_E'], z_init_HP = params['z_init_HP'], height_E = params['height_E'], height_HP = params['height_HP'], Q_dot_peak_E = params['Q_dot_peak_E'])
        # Tank model empirical parameters 
        WH.Model_parameters(h_amb = params['h_amb'], H_mix = params['H_mix'], V_s = params['V_s'], W_dot_el_basis = params['W_dot_el_basis'])
        #MN model initialization
        nx = self.nx
        # The first temperature initialization vector is used for the first tank 
        if WH.Model =='VELIS':
            T_init = self.T_init_Velis  # Initial temperature distribution 
            T_vect_init = np.full(nx, T_init)
            WH.MN_model_init(nx, T_vect_init, T_vect_init)
        else: 
            T_init = self.T_init  # Initial temperature distribution  
            T_vect_init = np.full(nx, T_init)
            WH.MN_model_init(nx, T_vect_init)
        return WH 

    def attach_WaterConsumptionProfile(self, nday, day_init):
        
        """
        Function to attach water consumption profiles to the water heaters 
        """
        for WH in self.pool_WH:
            T_constraint_bool = True
            V_dot_tot = 0 
            # number of people using the water heater in the house 
            WH.usage_profiles = WH.Total_volume//0.06 + 1*random.choice([0, 1]) 
            # 60 liters per person + a potential extra person
            # Loop to cumulate the water consumption profile of every people in the house
            for k in range(int(WH.usage_profiles)):
                V_dot_tot += self.DHW_load_gen(nday, day_init = day_init)
        
            WH.flow_rate_lps = V_dot_tot
        
    def simulate_pool_parallel(self,  nday, day_init = 0):
        """
        Simulate the pool of water heaters stating from day day_init of the year
        and finishing after nday (should be an int).
        
        Generate the total electrical consumption profile of the pool of water heaters
        
        Every water heater is simulated in parallel --> first loop on the time vector self.time_vect_com (60 seconds of time step)
        """
        self.time_vect_com = np.arange(0, nday*24*60*60, 60)
        self.time_vect_list = []
        self.P_vect_list = []
        self.P_vect_com_list = [[0.0] * len(self.time_vect_com) for _ in range(len(self.pool_WH))]
        self.T_out_vect_list = [[0.0] * len(self.time_vect_com) for _ in range(len(self.pool_WH))]
        self.T_probe_vect_list = [[(0.0 , 0.0)] * len(self.time_vect_com) for _ in range(len(self.pool_WH))]
        self.P_vect_cum = []
        self.V_dot_vect_cum = 0
        self.T_constraint_bool = [1]*len(self.pool_WH)
        self.attach_WaterConsumptionProfile(nday, day_init)
        self.E_sto_list = []
        self.P_sto_list = []
        print(f"Simulation of {self.N_VELIS} VELIS, {self.N_NUOS} NUOS, {self.N_random_E} random EWH and {self.N_random_HP} random HPWH...")       
        for t in range(len(self.time_vect_com)):
            cnt = 0
            P_vect_cum = 0
            for WH in self.pool_WH:
                T_out_wh = self.T_init
                index_pos = int(np.round(self.nx*(WH.control_ratio)))
                if WH.Model == 'VELIS':
                    self.T_probe_vect_list[cnt][t] = (WH.T_record1[-1][index_pos], WH.T_record2[-1][index_pos])
                    T_SP = self.T_SP_velis
                else: 
                    self.T_probe_vect_list[cnt][t] = (WH.T_record1[-1][index_pos], None)
                    T_SP = self.T_SP_normal
                    
                    

                if WH.flow_rate_lps[t] == 0: 
                    # Period of charge/rest
                    dt = self.tau_charge# seconds                   
                    m_dot = 0

                    switch1, switch2 = self.control_functions(WH, t*60, self.T_probe_vect_list[cnt][t], T_SP, strategy = self.pool_control_strategy)
                    time_period = 60 # seconds
                    
                    WH.MN_model_nocontrol(dt, time_period, m_dot, self.T_w_supply, self.T_amb, switch1, switch2, self.T_ext)       
                
                else: 
                    # Period of discharge - use of water
                    
                    dt = self.tau_discharge# seconds
                    time_period = 60 # seconds
                    T_out_wh = WH.T_w_out[-1] # no use of water when the simulation starts
                    WH.flow_rate_lps[t] = self.correct_flow_rate(WH.flow_rate_lps[t], T_out_wh)
                    m_dot = WH.flow_rate_lps[t]
                    switch1, switch2 = self.control_functions(WH, t*60, self.T_probe_vect_list[cnt][t], T_SP, strategy = self.pool_control_strategy)
                    WH.MN_model_nocontrol(dt, time_period, m_dot, self.T_w_supply, self.T_amb, switch1, switch2, self.T_ext)

                P_vect_cum += WH.W_dot_cons_tot[-1]
                self.T_out_vect_list[cnt][t] = WH.T_w_out[-1]
                self.P_vect_com_list[cnt][t] = WH.W_dot_cons_tot[-1]
                if WH.T_w_out[-1] < self.T_constraint:

                    self.T_constraint_bool[cnt] = 0
                if t == 0:
                    self.V_dot_vect_cum += WH.flow_rate_lps   
                cnt +=1
            self.P_vect_cum.append(P_vect_cum)
            P_sto, E_sto = self.E_storage_potential()
            self.E_sto_list.append(E_sto)
            self.P_sto_list.append(P_sto)
            # Print evolution of the simulation
            if t/60 % 4 == 0:
                print(f'{int(t/60 + 4)} hours simulated') 
        print(f'Ratio of temperature constraints ({self.T_constraint -273.15:.2f}°C) respected: {sum(self.T_constraint_bool)}/{len(self.pool_WH)}')        
   
    def control_functions(self, WH, time, T_probe, T_SP, strategy = 'tracking_SP') :    
        
        """
        Control strategy of the water heater
        Several strategy can be selected: 

        "tracking_SP": 
            - The system stops heating when the set point is exceeded by a temperature difference DT_high
            - The system starts heating when the control temperatrure is DT_low below the set point
            - switch2 always has the priority on switch 1 for the velis
            - The additional heating resistor is not used for the HPWH
        "mid_day_night": 
            - The system starts heating at midday or midnight and stops when the temperature 
              setpoint + DThigh is reached
        "full_heat": 
            - heat the system until the maximum water temperature is reached (80°C in every water heater)
              strategy for electricity storage (gives the maximum power and energy that can be stored over time)
            - heat the HPWH storage using the electrical resistor as well 
                      
        WH is the water heater class
        time is the time of the day in second,
        T_probe is the temperature measurement coming from the probe inside the tank(s)
        T_SP is the temperature setpoint
        """
        DT_high = -1
        DT_low = 7
        DT_high = 3
        DT_low = 3
        hyst = DT_low + DT_high
        T_SP = T_SP + DT_high
        if strategy == 'tracking_SP':
            if WH.Model == 'VELIS':
                T_probe1 = T_probe[0]
                T_probe2 = T_probe[1]
                if T_probe1 >= T_SP:
                    switch1 = False
                elif T_probe1 <= T_SP - hyst:
                    switch1 = True
                else:
                    switch1 = WH.switch1
                if T_probe2 >= T_SP:
                    switch2 = False
                elif T_probe2 <= T_SP - hyst:
                    switch2 = True
                else:
                    switch2 = WH.switch2
                if switch1 == True and switch2 == True: 
                    switch1 = False
                    
            elif WH.Model == 'random_E':   
                T_probe = T_probe[0]
                if T_probe >= T_SP:
                    switch1 = False
                elif T_probe <= T_SP - hyst:
                    switch1 = True
                else:
                    switch1 = WH.switch1
                switch2 = False
                
            else:
                T_probe = T_probe[0]
                if T_probe >= T_SP:
                    # print('wtf1')
                    switch2 = False
                elif T_probe <= T_SP - hyst:
                    # print('wtf2')
                    switch2 = True
                else:
                    # print('wtf3', WH.switch2)
                    switch2 = WH.switch2
                switch1 = False
                if T_probe > self.T_max_HP + DT_high:
                    switch2 = False

        if strategy ==  'mid_day_night':
            
            if time == 0 or time == 12*60*60 or WH.switch1 == True or WH.switch2 == True:
                if WH.Model == 'VELIS':
                    T_probe1 = T_probe[0]
                    T_probe2 = T_probe[1]
                    if T_probe1 >= T_SP:
                        switch1 = False
                    elif T_probe1 <= T_SP - hyst:
                        switch1 = True
                    else:
                        switch1 = WH.switch1
                    if T_probe2 >= T_SP:
                        switch2 = False
                    elif T_probe2 <= T_SP - hyst:
                        switch2 = True
                    else:
                        switch2 = WH.switch2
                    if switch1 == True and switch2 == True: 
                        switch1 = False
                        
                elif WH.Model == 'random_E':   
                    T_probe = T_probe[0]
                    if T_probe >= T_SP:
                        switch1 = False
                    elif T_probe <= T_SP - hyst:
                        switch1 = True
                    else:
                        switch1 = WH.switch1
                    switch2 = False
                    
                else:
                    T_probe = T_probe[0]
                    if T_probe >= T_SP:
                        switch2 = False
                    elif T_probe <= T_SP - hyst:
                        switch2 = True
                    else:
                        switch2 = WH.switch2
                    switch1 = False
                    if T_probe > self.T_max_HP:
                        switch2 = False

            else: 
                switch1 = False
                switch2 = False
                    
        if strategy ==  'full_load':
            T_max = self.T_max
            hyst = 5 #K 
            if WH.Model == 'VELIS':
                T_probe1 = T_probe[0]
                T_probe2 = T_probe[1]
                if T_probe1 >= T_max:
                    switch1 = False
                elif T_probe1 <= T_max - hyst:
                    switch1 = True
                else:
                    switch1 = WH.switch1
                if T_probe2 >= T_max:
                    switch2 = False
                elif T_probe2 <= T_max - hyst:
                    switch2 = True
                else:
                    switch2 = WH.switch2
                    
            elif WH.Model == 'random_E':   
                T_probe = T_probe[0]
                if T_probe >= T_max:
                    switch1 = False
                elif T_probe <= T_max - hyst:
                    switch1 = True
                else:
                    switch1 = WH.switch1
                switch2 = False
                
            else:
                T_probe = T_probe[0]
                if T_probe >= T_max:
                    switch2 = False
                elif T_probe <= T_max - hyst:
                    switch2 = True
                else:
                    switch2 = WH.switch2
                switch1 = switch2
                if T_probe > self.T_max_HP:
                    switch2 = False

                    
        return switch1, switch2
        
    def plot_available_storage(self): 
        """
        Plot the power that could be used instantly and the reserve of elecricity that can be stored 
        """

        xdim = 5.5+1
        ydim = 4.3
        labelsize = 18
        N_max = np.round(self.time_vect_com[-1]/3600)
        
        ## plot
        plt.figure(figsize=(xdim,ydim),constrained_layout=True)
        plt.rcParams.update({'font.size':16})
        params = {
                  "text.usetex" : True,
                  "font.family" : "cm"}
        plt.rcParams.update(params)
    
        ax1 = plt.subplot(2,1,1)
        plt.grid()

        plt.plot(self.time_vect_com/3600, np.array(self.P_sto_list) - np.array(self.P_vect_cum)/1000, 'k', linewidth = 1.5)


     
        plt.xlabel('Time [h]',fontsize=18,  fontname="Times New Roman")
        plt.ylabel('$\dot{W}_{el,sto}$ [kW]',fontsize=labelsize, fontname="Times New Roman" )            
        plt.xlim(0, N_max)
        plt.xticks(np.arange(0,N_max+1,4*N_max//24))
        
        ax2 = plt.subplot(2,1,2)
        plt.grid() 
        plt.plot(self.time_vect_com/3600, self.E_sto_list , 'k',  linewidth = 1.5)
        
        plt.xlabel('Time [h]',fontsize=18,  fontname="Times New Roman")
        plt.ylabel('$E_{el,sto}$ [kWh]',fontsize=labelsize, fontname="Times New Roman" )   
        plt.xlim(0, N_max)
        plt.xticks(np.arange(0,N_max+1,4*N_max//24))
        
        
    def plot_consumption(self): 
        """
        Plot the electricity consumption profile of all water heaters AND the cumulated profile as a function of time
        """
        xdim = 5.5+1
        ydim = 4.3
        labelsize = 18
        N_max = np.round(self.time_vect_com[-1]/3600)
        
        ## plot -- all profiles + total consumption 
        plt.figure(figsize=(xdim,ydim),constrained_layout=True)
        plt.rcParams.update({'font.size':16})
        params = {
                  "text.usetex" : True,
                  "font.family" : "cm"}
        plt.rcParams.update(params)
    
        ax1 = plt.subplot(2,1,1)
        plt.grid()
        for i in range(len(self.P_vect_com_list)): 
            plt.plot(self.time_vect_com/3600, self.P_vect_com_list[i] , 'k', linewidth = 0.5)


     
        plt.xlabel('Time [h]',fontsize=18,  fontname="Times New Roman")
        plt.ylabel('$\dot{W}_{el,i}$ [W]',fontsize=labelsize, fontname="Times New Roman" )            
        plt.xlim(0, N_max)
        plt.xticks(np.arange(0,N_max+1,4*N_max//24))
        
        ax2 = plt.subplot(2,1,2)
        plt.grid() 
        plt.plot(self.time_vect_com/3600, np.array(self.P_vect_cum)/1000 , 'k',  linewidth = 2)
        
        plt.xlabel('Time [h]',fontsize=18,  fontname="Times New Roman")
        plt.ylabel('$\sum \dot{W}_{el,i}$ [kW]',fontsize=labelsize, fontname="Times New Roman" )   
        plt.xlim(0, N_max)
        plt.xticks(np.arange(0,N_max+1,4*N_max//24))

        ## plot -- water consumption over time + total electricity consumption 
        plt.figure(figsize=(xdim,ydim),constrained_layout=True)
        plt.rcParams.update({'font.size':16})
        params = {
                  "text.usetex" : True,
                  "font.family" : "cm"}
        plt.rcParams.update(params)
    
        ax1 = plt.subplot(2,1,1)
        plt.grid()

        plt.plot(self.time_vect_com/3600, np.array(self.V_dot_vect_cum )*60, 'k', linewidth = 1.5)


     
        plt.xlabel('Time [h]',fontsize=18,  fontname="Times New Roman")
        plt.ylabel('$\sum \dot{V}_{w,i}$ [l/min]',fontsize=labelsize, fontname="Times New Roman" )           
        plt.xlim(0, N_max )
        plt.xticks(np.arange(0,N_max+1,4*N_max//24))
        
        ax2 = plt.subplot(2,1,2)
        plt.grid() 
        plt.plot(self.time_vect_com/3600, np.array(self.P_vect_cum)/1000 , 'k',  linewidth = 1.5)
        
        plt.xlabel('Time [h]',fontsize=18,  fontname="Times New Roman")
        plt.ylabel('$\sum \dot{W}_{el,i}$ [kW]',fontsize=labelsize, fontname="Times New Roman" )   
        plt.xlim(0, N_max)
        plt.xticks(np.arange(0,N_max+1,4*N_max//24))        
        

 
    def correct_flow_rate(self, V_dot_h, T_out_wh):
        
        """The hot water volumetric flow rate generated stochastically is based on a temperature of 50°C
        If the water temperature is different from 50°C, the volumetric flow rate is going to be different,
        as the thermostatic valve (from the tap, shower,...) increases/drecreases automatically the opening
        of the hot water passage"""
        
        # Constant density assumed whatever the temperature
        
        T_hot = 50 + 273.15 # K
        T_cold = self.T_w_supply
        T_constraint = self.T_constraint
        V_dot_tot = (T_hot - T_cold)/(T_constraint - T_cold)*V_dot_h
        
        V_dot_h_new = V_dot_h * (T_hot - T_cold)/(T_out_wh - T_cold)
        
        if T_out_wh <= T_constraint: # the constraint temperature is never gonna be reached --> maximum flow rate achieveable
            V_dot_h_new = V_dot_tot
            
        return V_dot_h_new
    
    def E_storage_potential(self):
        """
        Place the value in: 
        self.P_sto - available electric power in kW
        self.E_sto - available energy storage
        """
        P_sto = 0
        E_sto = 0 
        T_max = self.T_max
        cp = 4186 #J/(kgK)
        
        for WH in self.pool_WH:
            if WH.Model == 'VELIS':
                P_resistor = WH.param_heating['Q_dot_peak_E']*2
                T_mean = np.mean([WH.T_record1[-1] , WH.T_record2[-1]])
                P_HP = 0
            elif WH.Model == 'random_E':
                P_resistor = WH.param_heating['Q_dot_peak_E']
                T_mean = np.mean(WH.T_record1[-1])
                P_HP = 0
            else:
                P_resistor = WH.param_heating['Q_dot_peak_E']
                T_mean = np.mean(WH.T_record1[-1])
                P_HP, Q_dot_cd, _ = WH.HP_cycle(WH.T_record1[-1], True, self.T_ext)
            

            E_sto_wh = WH.Total_volume*1000 * cp * (T_max - T_mean)
            E_sto += E_sto_wh
            P_sto =  P_sto + P_resistor + P_HP
        
        P_sto = P_sto/1000 # kW        
        E_sto = E_sto/3.6/1e6 # kWh

        return  P_sto, E_sto 

    def save_results_csv(self, name):
        name = procF.wh.file_name_csv(name)
        # create dataframe         
        data = {
            'time_seconds': self.time_vect_com,
            'cumulated_power_kW': np.array(self.P_vect_cum)/1000,
            'cumulated_flow_lps': self.V_dot_vect_cum,
            'storage_available_kWh': self.E_sto_list,
            'power_available_kW': np.array(self.P_sto_list) - np.array(self.P_vect_cum)/1000
        }
        
        i = 0
        for WH in self.pool_WH:
            data[f'vdot_{i}_lps'] = WH.flow_rate_lps
            i +=1
            
        i = 0
        for WH in self.pool_WH:
            data[f'W_dot_el_{i}_W'] = self.P_vect_com_list[i]
            i +=1            
            
            
        df = pd.DataFrame(data)    
        
        
        list_file = ['..\\data\\Simulations\\' , name ,'.csv']
        
        # The complete file name is built up
        filename = "".join(list_file)       
        
        df.to_csv(filename, index = False, sep=';')
         
        
        
        
        
        
        
        